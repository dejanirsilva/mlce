<!DOCTYPE html>
<html lang="en"><head>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-html/tabby.min.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/light-border.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.8.25">

  <meta name="author" content="Dejanir Silva">
  <title>Machine Learning for Computational Economics</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="../site_libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="../site_libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      { color: #003b4f; background-color: #f1f3f5; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #003b4f; } /* Normal */
    code span.al { color: #ad0000; } /* Alert */
    code span.an { color: #5e5e5e; } /* Annotation */
    code span.at { color: #657422; } /* Attribute */
    code span.bn { color: #ad0000; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #003b4f; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #20794d; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #5e5e5e; } /* Comment */
    code span.cv { color: #5e5e5e; font-style: italic; } /* CommentVar */
    code span.do { color: #5e5e5e; font-style: italic; } /* Documentation */
    code span.dt { color: #ad0000; } /* DataType */
    code span.dv { color: #ad0000; } /* DecVal */
    code span.er { color: #ad0000; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #ad0000; } /* Float */
    code span.fu { color: #4758ab; } /* Function */
    code span.im { color: #00769e; } /* Import */
    code span.in { color: #5e5e5e; } /* Information */
    code span.kw { color: #003b4f; font-weight: bold; } /* Keyword */
    code span.op { color: #5e5e5e; } /* Operator */
    code span.ot { color: #003b4f; } /* Other */
    code span.pp { color: #ad0000; } /* Preprocessor */
    code span.sc { color: #5e5e5e; } /* SpecialChar */
    code span.ss { color: #20794d; } /* SpecialString */
    code span.st { color: #20794d; } /* String */
    code span.va { color: #111111; } /* Variable */
    code span.vs { color: #20794d; } /* VerbatimString */
    code span.wa { color: #5e5e5e; font-style: italic; } /* Warning */
    /* CSS for citations */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
      margin-bottom: 0em;
    }
    .hanging-indent div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }  </style>
  <link rel="stylesheet" href="../site_libs/revealjs/dist/theme/quarto-cfda842e1c2da8cd79357d57ebaa6bca.css">
  <link href="../site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
</head>
<body class="quarto-light">
  <div class="reveal">
    <div class="slides">

<section id="title-slide" class="quarto-title-block center">
  <h1 class="title">Machine Learning for Computational Economics</h1>
  <p class="subtitle"><span class="module-name">Module 02: Discrete-Time Methods</span><br><span class="school-name">EDHEC Business School</span></p>

<div class="quarto-title-authors">
<div class="quarto-title-author">
<div class="quarto-title-author-name">
Dejanir Silva 
</div>
        <p class="quarto-title-affiliation">
            Purdue University
          </p>
    </div>
</div>

  <p class="date">January 2026</p>
</section>
<section id="introduction" class="slide level2 compact-slide">
<h2>Introduction</h2>
<p><span class="text-orange"><strong>Discrete-time methods</strong></span> are the natural starting point for <em>dynamic programming</em>.</p>
<ul>
<li>In this module, we introduce classical numerical methods to solve such models.</li>
<li>These techniques provide a natural starting point for more advanced methods.</li>
</ul>
<div style="margin-top: 1.5em;">

</div>
<p>We illustrate these concepts with a <span class="text-blue"><strong>consumption-savings problem</strong></span></p>
<ul>
<li>This model is the backbone of many applications in macroeconomics and finance.</li>
<li>It is a key building block for many <em>heterogeneous-agent models</em>.</li>
</ul>
<div style="margin-top: 1.5em;">

</div>
<p>This benchmark problem allows us to illustrate three core computational tasks:</p>
<ol type="1">
<li><em>Representing</em> value and policy functions on a grid</li>
<li>Computing <em>expectations</em> in problems with uncertainty</li>
<li>Performing the <em>maximization</em> step efficiently</li>
</ol>
</section>
<section>
<section id="i.-the-consumption-savings-problem" class="title-slide slide level1 center">
<h1>I. The Consumption-Savings Problem</h1>

</section>
<section id="a-consumption-savings-problem" class="slide level2 compact-slide">
<h2>A Consumption-Savings Problem</h2>
<p>Consider a household deciding how much to consume and save when income is uncertain.</p>
<ul>
<li>The household enters each period with cash-on-hand <span class="math inline">\(M_t\)</span>, sum of financial wealth <span class="math inline">\(W_t\)</span> and labor income <span class="math inline">\(Y_t\)</span>.</li>
<li>The household earns a risk-free return <span class="math inline">\(R\)</span> on her savings</li>
</ul>
<div class="fragment">
<p>Cash-on-hand evolves according to: <span class="math display">\[  
  M_{t+1} = \color{#0072b2}{\underbrace{R\,(M_t - c_t)}_{\text{return on savings}}} + \color{#d55e00}{\underbrace{Y_{t+1}}_{\text{labor income}}}.
\]</span></p>
</div>
<div class="fragment">
<p>The household’s problem is to choose a consumption plan <span class="math inline">\(\{c_t\}_{t=0}^{T-1}\)</span> that maximizes expected lifetime utility: <span class="math display">\[  
  V_T(M)
  = \max_{\{c_t\}_{t=0}^{T-1}}
    \mathbb{E}\!\left[
      \sum_{t=0}^{T-1} e^{-\rho t}\, u(c_t)
      + e^{-\rho T}\, \color{#009e73}{\underbrace{V_0(M_T)}_{\text{terminal payoff}}}
    \right],
\]</span><br>
subject to the transition equation for cash-on-hand and the stochastic process for labor income, <span class="math display">\[  
  \log Y_{t+1} \sim \mathcal{N}\!\left(- \tfrac{1}{2}\sigma_y^2,\, \sigma_y^2\right),
\]</span> where the normalization ensures that <span class="math inline">\(\mathbb{E}[Y_t] = 1\)</span>.</p>
</div>
</section>
<section id="the-recursive-representation" class="slide level2 compact-slide">
<h2>The Recursive Representation</h2>
<p>The recursive problem is given by <span class="math display">\[  
  V_t(M)
  = \max_{c}
    \left\{
      u(c) + e^{-\rho} \mathbb{E}\!\left[ V_{t-1}(M') \right]
    \right\},
\]</span><br>
subject to <span class="math display">\[  
  M' = R (M - c) + Y', \qquad
  \log Y' \sim \mathcal{N}\!\left(- \tfrac{1}{2}\sigma_y^2,\, \sigma_y^2\right).
\]</span></p>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<p>Preferences and terminal payoff are of the constant relative risk aversion (CRRA) form: <span class="math display">\[  
  u(c) = \frac{c^{1-\gamma}}{1-\gamma}, \qquad
  V_0(M) = A \frac{M^{1-\gamma}}{1-\gamma}.
\]</span><br>
where <span class="math inline">\(\gamma &gt; 0\)</span> is the coefficient of relative risk aversion and <span class="math inline">\(A &gt; 0\)</span> is a scaling parameter.</p>
<!-- Given the value function $V_{t-1}(M)$, the <span class="text-orange">**first-order condition**</span> for the optimal policy $c_t(M)$ is
$$  
  u'(c_t(M))
  = e^{-\rho}\, \mathbb{E}\!\left[ V_{t-1}'(R(M - c_t(M)) + Y') R \right].
$$   -->
</div>
<div class="fragment">
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Note</strong></p>
</div>
<div class="callout-content">
<p>The <span class="text-blue"><strong>infinite-horizon problem</strong></span>, where <span class="math inline">\(T \to \infty\)</span>, corresponds to the stationary solution of the recursive problem. In this case, the value function satisfies the fixed-point condition <span class="math inline">\(V_t(M) = V_{t-1}(M) \equiv V(M)\)</span>.</p>
</div>
</div>
</div>
</div>
</section>
<section id="the-action-value-function" class="slide level2 compact-slide">
<h2>The Action-Value Function</h2>
<p>The action-value function is given by <span class="math display">\[  
  V_t(M, c)
  \equiv
      u(c) + e^{-\rho} \mathbb{E}\!\left[ V_{t-1}(R (M- c) + Y') \right].
\]</span></p>
<div class="callout callout-tip callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Tip</strong></p>
</div>
<div class="callout-content">
<p>The <em>action-value function</em> corresponds to the value associated with a given action (no maximization step).</p>
</div>
</div>
</div>
<div class="fragment">
<div class="columns">
<div class="column" style="width:60%;">
<p><img data-src="Figures/action_value.png" style="width:100.0%"></p>
</div><div class="column" style="width:40%;">
<p>Think of <span class="math inline">\(V_t(M,c)\)</span> as a table</p>
<ul>
<li>Columns: actions <span class="math inline">\(c\)</span></li>
<li>Rows: states <span class="math inline">\(M\)</span></li>
</ul>
<div style="margin-top: 1em;">

</div>
<p><span class="text-orange"><strong>Optimal consumption:</strong></span> <span class="math display">\[c_t(M) = \arg\max_{c} V_t(M,c)\]</span></p>
</div></div>
</div>
</section>
<section id="value-function-iteration" class="slide level2 compact-slide">
<h2>Value Function Iteration</h2>
<p>We can solve the Bellman equation by <span class="text-orange"><strong>value function iteration</strong></span> (VFI).</p>
<ul>
<li>Given <span class="math inline">\(V^{(0)}(M)\)</span>, find the optimal consumption: <span class="math inline">\(c^{(1)}(M) = \arg\max_{c} V^{(1)}(M,c)\)</span>.<br>
</li>
<li>Update the value function as <span class="math inline">\(V_1(M) = V_1(M, c_1(M))\)</span>.</li>
</ul>
<div class="fragment">
<div style="background-color: #f5f5f5; padding: 1em; border-left: 4px solid #0072b2; margin: 1em 0; font-size: 0.85em;">
<p><strong>Algorithm: Value Function Iteration (VFI)</strong></p>
<p><strong>Input:</strong> Initial guess <span class="math inline">\(V^{(0)}(M)\)</span>, tolerance <code>tol</code><br>
<strong>Output:</strong> Value <span class="math inline">\(V(M)\)</span>, policy <span class="math inline">\(c^*(M)\)</span><br>
<strong>Initialize:</strong> <span class="math inline">\(t \gets 0\)</span></p>
<p><strong>Repeat</strong> until <span class="math inline">\(\|V^{(t+1)}-V^{(t)}\|_\infty &lt; \texttt{tol}\)</span>:</p>
<ul>
<li><p><strong>Policy update:</strong> <span class="math display">\[c_{t+1}(M) \gets \arg\max_{c}\left\{ u(c) + e^{-\rho}\,\mathbb{E}[V_{t}(R(M-c)+Y')] \right\}\]</span></p></li>
<li><p><strong>Value update:</strong> <span class="math display">\[V_{t+1}(M) \gets u(c_{t+1}(M)) + e^{-\rho}\,\mathbb{E}\left[ V_{t}(R(M-c_{t+1}(M))+Y') \right]\]</span></p></li>
<li><p><span class="math inline">\(t \gets t+1\)</span></p></li>
</ul>
<p><strong>Return:</strong> <span class="math inline">\(V^{(t)},\,c^{(t)}\)</span></p>
</div>
</div>
</section></section>
<section>
<section id="ii.-numerical-solution" class="title-slide slide level1 center">
<h1>II. Numerical Solution</h1>

</section>
<section id="numerical-solution" class="slide level2 compact-slide" data-grey-previous="true">
<h2>Numerical Solution</h2>
<p>There is no known analytical solution to this problem.</p>
<ul>
<li>We must then resort to <em>numerical methods</em>.</li>
</ul>
<div style="margin-top: 1.5em;">

</div>
<p>To solve the problem numerically, we must overcome three main challenges:</p>
<div class="fragment" data-fragment-index="1">
<ol type="1">
<li><span class="text-blue"><strong>Represent</strong></span> the value function in the computer</li>
</ol>
</div>
<div class="fragment" data-fragment-index="2">
<ol start="2" type="1">
<li>Compute <span class="text-green"><strong>expectations</strong></span> in problems with uncertainty</li>
</ol>
</div>
<div class="fragment" data-fragment-index="3">
<ol start="3" type="1">
<li>Perform the <span class="text-orange"><strong>maximization</strong></span> step efficiently</li>
</ol>
</div>
</section>
<section id="representing-the-value-function" class="slide level2 compact-slide">
<h2>Representing the Value Function</h2>
<p>We need to find a way to represent the value function in the computer.</p>
<ul>
<li>We need a <em>finite representation</em> of an infinite-dimensional object.</li>
<li>In our single-state problem, this can be done by representing the value function on a <em>grid</em>.</li>
</ul>
<div class="fragment">
<p>We begin by constructing a finite grid for <span class="math inline">\(M\)</span>: <span class="math display">\[
  M \in \mathcal{M} = \{M_{1}, M_{2}, \ldots, M_{N}\}.
\]</span></p>
<div id="2" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a></a>Mgrid <span class="op">=</span> <span class="fu">collect</span>(<span class="fu">range</span>(<span class="fl">0.0</span>, <span class="fl">3.0</span>, length<span class="op">=</span><span class="fl">9</span>)) <span class="co"># uniform grid for M</span></span>
<span id="cb1-2"><a></a>Mgrid<span class="op">'</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>1×9 adjoint(::Vector{Float64}) with eltype Float64:
 0.0  0.375  0.75  1.125  1.5  1.875  2.25  2.625  3.0</code></pre>
</div>
</div>
</div>
<div class="fragment">
<p>At each point on this grid, we store the corresponding value function as a vector: <span class="math display">\[
  \mathbf{V}_t = (V_{t,1}, V_{t,2}, \ldots, V_{t,N})^\top,
  \qquad \text{where } V_{t,i} \equiv V_t(M_i).
\]</span></p>
</div>
<div class="fragment">
<p>Similarly, the optimal consumption policy can be represented as a vector: <span class="math display">\[
  \mathbf{c}_t = (c_{t,1}, c_{t,2}, \ldots, c_{t,N})^\top,
  \qquad \text{where } c_{t,i} \equiv c_t(M_i).
\]</span></p>
</div>
</section>
<section id="interpolating-the-value-function" class="slide level2 compact-slide">
<h2>Interpolating the Value Function</h2>
<p>Suppose we start with the initial value function represented on a grid: <span class="math inline">\(\mathbf{V}_0\)</span>.</p>
<ul>
<li>To compute <span class="math inline">\(\mathbb{E}[V_0(R(M-c)+Y')]\)</span>, we need to evaluate the value function at points outside the grid.</li>
<li>We can use <span class="text-orange"><strong>linear interpolation</strong></span> to approximate the value function between grid points.</li>
</ul>
<div style="margin-top: 1.75em;">

</div>
<div class="fragment">
<p>For <span class="math inline">\(M \in [M_{i-1}, M_i]\)</span>, we assume that <span class="math inline">\(V_t(M)\)</span> is linear and approximate it as <span class="math display">\[
  V_t(M)
  \approx
  \frac{M - M_{i-1}}{M_i - M_{i-1}}\, V_{t,i}
  + \frac{M_i - M}{M_i - M_{i-1}}\, V_{t,i-1}.
\]</span></p>
<div style="margin-top: 1.75em;">

</div>
</div>
<div class="fragment">
<p>We can implement linear interpolation using the <code>Interpolations.jl</code> package.</p>
<div id="4" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a></a><span class="im">using</span> <span class="bu">Interpolations</span></span>
<span id="cb3-2"><a></a>Mgrid    <span class="op">=</span> <span class="fu">collect</span>(<span class="fu">range</span>(<span class="fl">0.0</span>, <span class="fl">3.0</span>, length<span class="op">=</span><span class="fl">9</span>)) <span class="co"># uniform grid for M</span></span>
<span id="cb3-3"><a></a>V_0      <span class="op">=</span> [M<span class="op">^</span>(<span class="fl">1</span><span class="op">-</span><span class="fl">2</span>)<span class="op">/</span>(<span class="fl">1</span><span class="op">-</span><span class="fl">2</span>) for M <span class="kw">in</span> Mgrid] <span class="co"># γ = 2</span></span>
<span id="cb3-4"><a></a>V_interp <span class="op">=</span> <span class="fu">linear_interpolation</span>(Mgrid, V_0)</span>
<span id="cb3-5"><a></a><span class="fu">V_interp</span>(<span class="cn">π</span><span class="op">/</span><span class="fl">2</span>) <span class="co"># evaluating at point outside the grid</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>-0.6414946393618145</code></pre>
</div>
</div>
</div>
</section>
<section id="accuracy-of-a-linear-interpolation" class="slide level2 compact-slide">
<h2>Accuracy of a Linear Interpolation</h2>
<p>The accuracy of a linear interpolation depends on the grid size.</p>
<ul>
<li>We can approximate even very non-linear functions this way.</li>
<li>Depending on the function, this may require a very fine grid.</li>
</ul>
<div class="columns">
<div class="column" style="width:55%;">
<p><img data-src="Figures/V0.png" style="width:100.0%"></p>
</div><div class="column" style="width:45%;">
<p>Quality of approximation may not be <em>uniform</em></p>
<ul>
<li>Worse approximation near the boundaries.</li>
</ul>
<div style="margin-top: 1.75em;">

</div>
<p>Uniform grid can be very inefficient</p>
<ul>
<li>It does not allow to focus where it is needed</li>
</ul>
</div></div>
</section>
<section id="non-uniform-grids" class="slide level2 compact-slide">
<h2>Non-Uniform Grids</h2>
<p>An alternative is to use a non-uniform grid for the state variable.</p>
<div class="columns">
<div class="column" style="width:55%;">
<p><img data-src="Figures/non_uniform_grid.png" style="width:100.0%"></p>
</div><div class="column" style="width:45%;">
<p>A convenient choice is the <span class="text-orange"><strong>double-exponential grid</strong></span></p>
<ul>
<li>Clusters grid points near the lower bound.</li>
<li>Let <span class="math inline">\(u^j\)</span> denote a uniform grid on the unit interval <span class="math inline">\([0,1]\)</span>.</li>
<li>Define the grid points as <span class="math display">\[
a_j = a_{\min} + (a_{\max} - a_{\min}) \frac{e^{\,e^{\alpha u^j}-1} - 1}{e^{\,e^{\alpha}-1} - 1},
\]</span></li>
</ul>
<p>The parameter <span class="math inline">\(\alpha &gt; 0\)</span> controls the degree of clustering.</p>
<ul>
<li>As <span class="math inline">\(\alpha \to 0\)</span>, the grid becomes approximately uniform.</li>
<li>For large <span class="math inline">\(\alpha\)</span>, the grid is very dense near the lower bound.</li>
</ul>
</div></div>
<p>We can implement this in Julia as follows:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a></a><span class="kw">function</span> <span class="fu">make_grid</span>(zmin, zmax, Nz; α <span class="op">=</span> <span class="fl">1.0</span>)</span>
<span id="cb5-2"><a></a>    u <span class="op">=</span> <span class="fu">range</span>(<span class="fl">0.0</span>, <span class="fl">1.0</span>, length<span class="op">=</span>Nz)</span>
<span id="cb5-3"><a></a>    double_exp <span class="op">=</span> α <span class="op">==</span> <span class="fl">0</span> ? u <span class="op">:</span> @. (<span class="fu">exp</span>(<span class="fu">exp</span>(α <span class="op">*</span> u) <span class="op">-</span> <span class="fl">1.0</span>) <span class="op">-</span> <span class="fl">1.0</span>) <span class="op">/</span> (<span class="fu">exp</span>(<span class="fu">exp</span>(α) <span class="op">-</span> <span class="fl">1.0</span>) <span class="op">-</span> <span class="fl">1.0</span>)</span>
<span id="cb5-4"><a></a>    <span class="cf">return</span> @. zmin <span class="op">+</span> (zmax <span class="op">-</span> zmin) <span class="op">*</span> double_exp</span>
<span id="cb5-5"><a></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="computing-expectations" class="slide level2 compact-slide">
<h2>Computing Expectations</h2>
<p>The second issue we must address is how to compute <span class="text-green"><strong>expectations</strong></span>.</p>
<ul>
<li>In our setting, this amounts to integrating over the stochastic labor income <span class="math inline">\(Y'\)</span>.</li>
</ul>
<div style="margin-top: 1.75em;">

</div>
<div class="fragment">
<p>The expectation in the Bellman equation can be written as the integral: <span class="math display">\[
  \mathbb{E}\!\left[V_{t}(M')\right] = \int_{-\infty}^{\infty} V_t(R(M - c_t(M)) + e^{y'}) \phi(y') d y',
\]</span> where <span class="math inline">\(\phi(y')\)</span> is the probability density function of a normal random variable.</p>
</div>
<div class="fragment">
<div style="margin-top: 1.75em;">

</div>
<p>Computing this expectation numerically requires approximating the integral.</p>
<ul>
<li>A common approach is to discretize the process for the log income <span class="math inline">\(y_t \equiv \log Y_t\)</span></li>
<li>We replace the continuous process by a <em>finite-state Markov chain</em>.</li>
<li>Next: construct a grid and transition probabilities for the Markov chain.</li>
</ul>
</div>
</section>
<section id="the-tauchen-method-constructing-the-grid" class="slide level2 compact-slide">
<h2>The Tauchen Method: Constructing the Grid</h2>
<p>The Tauchen method is a common approach to discretize the process for an AR(1) process: <span class="math display">\[
  z_{t+1} = \mu + \rho_z (z_t - \mu) + \varepsilon_{t+1},
  \qquad \varepsilon_{t+1} \sim \mathcal{N}(0, \sigma_\varepsilon^2),
\]</span> where <span class="math inline">\(|\rho_z| &lt; 1\)</span> and <span class="math inline">\(\sigma_\varepsilon &gt; 0\)</span> (in our case, <span class="math inline">\(\rho_z = 0\)</span> and <span class="math inline">\(\sigma_\varepsilon = \sigma_y\)</span>).</p>
<div style="margin-top: 1.75em;">

</div>
<div class="fragment">
<p>We start by constructing an uniform grid <span class="math display">\[
  z \in \mathcal{Z} = \{z_1, z_2, \ldots, z_{N_z}\},
\]</span> with step size <span class="math inline">\(\Delta = \frac{z_{N_z} - z_1}{N_z - 1}\)</span>.</p>
<div style="margin-top: 1.75em;">

</div>
<p>A convenient choice for the endpoints is <span class="math display">\[
  z_1 = \mu - m\,\frac{\sigma_z}{\sqrt{1 - \rho_z^2}},
  \qquad
  z_{N_z} = \mu + m\,\frac{\sigma_z}{\sqrt{1 - \rho_z^2}},
\]</span> where <span class="math inline">\(m\)</span> is typically set to <span class="math inline">\(3\)</span>, ensuring that the grid spans <span class="math inline">\(\pm3\)</span> unconditional standard deviations of <span class="math inline">\(z_t\)</span>.</p>
</div>
</section>
<section id="the-tauchen-method-computing-the-transition-probabilities" class="slide level2 compact-slide">
<h2>The Tauchen Method: Computing the Transition Probabilities</h2>
<p>We need to determine the transition probabilities <span class="math inline">\(P_{ij} = \Pr(z_{t+1} = z_j \mid z_t = z_i)\)</span>.</p>
<ul>
<li>Conditional on <span class="math inline">\(z_t = z_i\)</span>, we have that <span class="math inline">\(z_{t+1} \sim \mathcal{N}\left(\mu + \rho_z (z_i - \mu), \sigma_\varepsilon^2\right)\)</span>.</li>
</ul>
<!-- - 
$$
  P_{ij} = \Pr(z_{t+1} \in [z_j - \Delta/2, z_j + \Delta/2] \mid z_t = z_i).
$$ -->
<p>The transition probability <span class="math inline">\(P_{ij}\)</span> equals the probability that <span class="math inline">\(z_{t+1}\)</span> falls between the midpoints surrounding <span class="math inline">\(z_j\)</span>:</p>
<div class="columns">
<div class="column" style="width:50%;">
<p><span class="math display">\[\scriptsize
  P_{ij} =
  \begin{cases}
    \Phi\!\left(\dfrac{z_j - \mu_i + \tfrac{\Delta}{2}}{\sigma_\varepsilon}\right),
      &amp; j = 1, \\[0.75em]
    \Phi\!\left(\dfrac{z_j - \mu_i + \tfrac{\Delta}{2}}{\sigma_\varepsilon}\right)
      - \Phi\!\left(\dfrac{z_j - \mu_i - \tfrac{\Delta}{2}}{\sigma_\varepsilon}\right),
      &amp; 1 &lt; j &lt; N_z, \\[0.75em]
    1 - \Phi\!\left(\dfrac{z_j - \mu_i - \tfrac{\Delta}{2}}{\sigma_\varepsilon}\right),
      &amp; j = N_z,
  \end{cases}
\]</span></p>
</div><div class="column" style="width:50%;">
<p><img data-src="Figures/tauchen.png" style="width:100.0%"></p>
</div></div>
</section>
<section id="the-tauchen-method-in-julia" class="slide level2 compact-slide">
<h2>The Tauchen Method in Julia</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="tauchen-code" data-code-line-numbers="1-30|8-9|10|11-14|15-19|20-25|26-27|1-30"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="tauchen-code-1"><a href="#tauchen-code-1"></a><span class="st">"""</span></span>
<span id="tauchen-code-2"><a href="#tauchen-code-2"></a><span class="st">Tauchen (1986) discretization of the AR(1) process</span></span>
<span id="tauchen-code-3"><a href="#tauchen-code-3"></a><span class="st">    z_{t+1} = μ + ρ z_t + ε_{t+1},   ε ~ N(0, σϵ^2).</span></span>
<span id="tauchen-code-4"><a href="#tauchen-code-4"></a><span class="st">"""</span></span>
<span id="tauchen-code-5"><a href="#tauchen-code-5"></a><span class="kw">function</span> <span class="fu">tauchen</span>(M<span class="op">::</span><span class="dt">Int</span>, ρ<span class="op">::</span><span class="dt">Real</span>, σϵ<span class="op">::</span><span class="dt">Real</span>; μ<span class="op">::</span><span class="dt">Real</span>=<span class="fl">0.0</span>, m<span class="op">::</span><span class="dt">Real</span>=<span class="fl">3.0</span>)</span>
<span id="tauchen-code-6"><a href="#tauchen-code-6"></a>    <span class="pp">@assert</span> M <span class="op">≥</span> <span class="fl">2</span> <span class="st">"Need at least M=2 grid points."</span></span>
<span id="tauchen-code-7"><a href="#tauchen-code-7"></a>    <span class="pp">@assert</span> <span class="fu">abs</span>(ρ) <span class="op">&lt;</span> <span class="fl">1</span> <span class="st">"Require |ρ|&lt;1 for stationary AR(1)."</span></span>
<span id="tauchen-code-8"><a href="#tauchen-code-8"></a>    σz <span class="op">=</span> σϵ <span class="op">/</span> <span class="fu">sqrt</span>(<span class="fl">1</span> <span class="op">-</span> ρ<span class="op">^</span><span class="fl">2</span>)                <span class="co"># unconditional std. dev.</span></span>
<span id="tauchen-code-9"><a href="#tauchen-code-9"></a>    z̄ <span class="op">=</span> μ <span class="op">/</span> (<span class="fl">1</span> <span class="op">-</span> ρ)                        <span class="co"># unconditional mean</span></span>
<span id="tauchen-code-10"><a href="#tauchen-code-10"></a>    <span class="cf">if</span> σϵ <span class="op">==</span> <span class="fl">0.0</span> <span class="cf">return</span> (; z <span class="op">=</span> [z̄], P <span class="op">=</span> [<span class="fl">1.0</span>]) <span class="cf">end</span> <span class="co"># degenerate case</span></span>
<span id="tauchen-code-11"><a href="#tauchen-code-11"></a>    zmin, zmax <span class="op">=</span> z̄ <span class="op">-</span> m<span class="op">*</span>σz, z̄ <span class="op">+</span> m<span class="op">*</span>σz</span>
<span id="tauchen-code-12"><a href="#tauchen-code-12"></a>    Δ <span class="op">=</span> (zmax <span class="op">-</span> zmin) <span class="op">/</span> (M <span class="op">-</span> <span class="fl">1</span>)</span>
<span id="tauchen-code-13"><a href="#tauchen-code-13"></a>    z <span class="op">=</span> <span class="fu">collect</span>(<span class="fu">range</span>(zmin, zmax, length<span class="op">=</span>M))</span>
<span id="tauchen-code-14"><a href="#tauchen-code-14"></a>    P <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Float64</span>, M, M)</span>
<span id="tauchen-code-15"><a href="#tauchen-code-15"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>M</span>
<span id="tauchen-code-16"><a href="#tauchen-code-16"></a>        mean_next <span class="op">=</span> μ <span class="op">+</span> ρ<span class="op">*</span>z[i]</span>
<span id="tauchen-code-17"><a href="#tauchen-code-17"></a>        dist <span class="op">=</span> <span class="fu">Normal</span>(mean_next, σϵ)</span>
<span id="tauchen-code-18"><a href="#tauchen-code-18"></a>        <span class="co"># First bin: (−∞, midpoint_1]</span></span>
<span id="tauchen-code-19"><a href="#tauchen-code-19"></a>        P[i, <span class="fl">1</span>] <span class="op">=</span> <span class="fu">cdf</span>(dist, z[<span class="fl">1</span>] <span class="op">+</span> Δ<span class="op">/</span><span class="fl">2</span>)</span>
<span id="tauchen-code-20"><a href="#tauchen-code-20"></a>        <span class="co"># Interior bins: (midpoint_{j-1}, midpoint_j]</span></span>
<span id="tauchen-code-21"><a href="#tauchen-code-21"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span>M<span class="op">-</span><span class="fl">1</span></span>
<span id="tauchen-code-22"><a href="#tauchen-code-22"></a>            upper <span class="op">=</span> z[j] <span class="op">+</span> Δ<span class="op">/</span><span class="fl">2</span></span>
<span id="tauchen-code-23"><a href="#tauchen-code-23"></a>            lower <span class="op">=</span> z[j] <span class="op">-</span> Δ<span class="op">/</span><span class="fl">2</span></span>
<span id="tauchen-code-24"><a href="#tauchen-code-24"></a>            P[i, j] <span class="op">=</span> <span class="fu">cdf</span>(dist, upper) <span class="op">-</span> <span class="fu">cdf</span>(dist, lower)</span>
<span id="tauchen-code-25"><a href="#tauchen-code-25"></a>        <span class="cf">end</span></span>
<span id="tauchen-code-26"><a href="#tauchen-code-26"></a>        <span class="co"># Last bin: (midpoint_{N-1}, +∞)</span></span>
<span id="tauchen-code-27"><a href="#tauchen-code-27"></a>        P[i, M] <span class="op">=</span> <span class="fl">1</span> <span class="op">-</span> <span class="fu">cdf</span>(dist, z[M] <span class="op">-</span> Δ<span class="op">/</span><span class="fl">2</span>)</span>
<span id="tauchen-code-28"><a href="#tauchen-code-28"></a>    <span class="cf">end</span></span>
<span id="tauchen-code-29"><a href="#tauchen-code-29"></a>    <span class="cf">return</span> (;z, P)</span>
<span id="tauchen-code-30"><a href="#tauchen-code-30"></a><span class="kw">end</span>;</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<!-- ```{julia}
#| echo: true
#| label: tauchen
"""
Tauchen (1986) discretization of the AR(1) process
    z_{t+1} = μ + ρ z_t + ε_{t+1},   ε ~ N(0, σϵ^2).
"""
function tauchen(M::Int, ρ::Real, σϵ::Real; μ::Real=0.0, m::Real=3.0)
    @assert M ≥ 2 "Need at least M=2 grid points."
    @assert abs(ρ) < 1 "Require |ρ|<1 for stationary AR(1)."
    σz = σϵ / sqrt(1 - ρ^2)                # unconditional std. dev.
    z̄ = μ / (1 - ρ)                        # unconditional mean
    if σϵ == 0.0 return (; z = [z̄], P = [1.0]) end # degenerate case
    zmin, zmax = z̄ - m*σz, z̄ + m*σz
    Δ = (zmax - zmin) / (M - 1)
    z = collect(range(zmin, zmax, length=M))
    P = zeros(Float64, M, M)
    for i in 1:M
        mean_next = μ + ρ*z[i]
        dist = Normal(mean_next, σϵ)
        # First bin: (−∞, midpoint_1]
        P[i, 1] = cdf(dist, z[1] + Δ/2)
        # Interior bins: (midpoint_{j-1}, midpoint_j]
        for j in 2:M-1
            upper = z[j] + Δ/2
            lower = z[j] - Δ/2
            P[i, j] = cdf(dist, upper) - cdf(dist, lower)
        end
        # Last bin: (midpoint_{N-1}, +∞)
        P[i, M] = 1 - cdf(dist, z[M] - Δ/2)
    end
    return (;z, P)
end;
``` -->
</section>
<section id="conditional-moments-exact-vs.-markov-chain-approximation" class="slide level2 compact-slide">
<h2>Conditional Moments: Exact vs.&nbsp;Markov Chain Approximation</h2>

<img data-src="Figures/plots_tauchen.png" style="width:100.0%" class="r-stretch"><div class="callout callout-important callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Important</strong></p>
</div>
<div class="callout-content">
<p>Tauchen’s method works particularly well for processes with moderate persistence. For highly persistent processes, the quadrature-based method of <span class="citation" data-cites="TauchenHussey1991">Tauchen and Hussey (<a href="#/references" role="doc-biblioref" onclick="">1991</a>)</span> or the recursive scheme of <span class="citation" data-cites="Rouwenhorst1995">Rouwenhorst (<a href="#/references" role="doc-biblioref" onclick="">1995</a>)</span> provides greater accuracy.</p>
</div>
</div>
</div>
</section>
<section id="the-optimization-step" class="slide level2 compact-slide">
<h2>The optimization step</h2>
<p>The third issue we must address is how to perform the <span class="text-orange"><strong>maximization</strong></span> step efficiently.</p>
<ul>
<li><p>A direct approach is to specify a grid for the control variable <span class="math inline">\(c \in \mathcal{C} = \{c_1, c_2, \ldots, c_{N_c}\}\)</span></p></li>
<li><p>The optimal consumption is given by <span class="math inline">\(c_t(M) = \arg\max_{c} V_t(M, c)\)</span>.</p></li>
</ul>
<div class="fragment">
<div style="margin-top: 0.75em;">

</div>
<p>This brute-force approach can be computationally expensive</p>
<ul>
<li>An alternative is to use the first-order condition and envelope condition:</li>
</ul>
<p><span class="math display">\[
\color{#0072b2}{\underbrace{u'(c_t(M)) = e^{-\rho} R \sum_{j=1}^{N_y} P_j\, V_{t-1}'\!\left(R (M - c_t(M)) + Y'_j\right)}_{\text{first-order condition}}} , \qquad \qquad \color{#d55e00}{\underbrace{V_{t}'(M) = u'(c_{t}(M))}_{\text{envelope condition}}}
\]</span></p>
<div style="margin-top: 0.75em;">

</div>
</div>
<div class="fragment">
<p>Combining the two conditions, we obtain the <em>consumption Euler equation</em>: <span class="math display">\[
  u'(c_t(M)) = e^{-\rho} R \sum_{j=1}^{N_y} P_j\, u'\!\left(c_{t-1}\!\left(R (M - c_t(M)) + Y'_j\right)\right).
\]</span></p>
<p>To obtain <span class="math inline">\(c_t(M)\)</span>, we need to solve a nonlinear equation for each <span class="math inline">\(M\)</span>.</p>
</div>
</section>
<section id="egm-steps" class="slide level2 compact-slide" data-grey-previous="true">
<h2>The Endogenous Gridpoint Method</h2>
<p><span class="citation" data-cites="Carroll2006">Carroll (<a href="#/references" role="doc-biblioref" onclick="">2006</a>)</span> proposed the <em>endogenous gridpoint method</em> (EGM) that avoids the root-finding step:</p>
<div class="fragment" data-fragment-index="1">
<ol type="1">
<li>Define a grid for the end-of-period assets <span class="math inline">\(a_t(M) \equiv M - c_t(M)\)</span>: <span class="math display">\[
   a_t(M) \in \mathcal{A} = \{a_1, a_2, \ldots, a_{N_a}\}
\]</span></li>
</ol>
</div>
<div class="fragment" data-fragment-index="2">
<ol start="2" type="1">
<li>Solve for consumption inverting the consumption Euler equation: <span class="math display">\[
   c_{t,i} = u'^{-1}\!\left( e^{-\rho} R \sum_{j=1}^{N_y} P_j\, u'\!\left(c_{t-1}\!\left(R a_i + Y'_j\right)\right) \right).
\]</span></li>
</ol>
</div>
<div class="fragment" data-fragment-index="3">
<ol start="3" type="1">
<li>Interpolate the new policy function over the endogenous grid: <span class="math display">\[
   M_{t,i} = a_i + c_{t,i}.
\]</span></li>
</ol>
</div>
<div class="fragment" data-fragment-index="4">
<ol start="4" type="1">
<li>Update the value function: <span class="math display">\[
   V_t(M) = u(c_t(M)) + e^{-\rho} \sum_{j=1}^{N_y} P_j\, V_{t-1}\!\left(R (M - c_t(M)) + Y'_j\right).
\]</span></li>
</ol>
</div>
</section></section>
<section>
<section id="iii.-julia-implementation" class="title-slide slide level1 center">
<h1>III. Julia Implementation</h1>

</section>
<section id="model-struct" class="slide level2 compact-slide">
<h2>Model Struct</h2>
<p>We have seen how to represent the value function, compute expectations, and perform the maximization step.</p>
<ul>
<li>We are now ready to solve for the value and policy functions.</li>
<li>To make the implementation modular and reusable, we encapsulate all parameters and grids in a Julia <span class="text-orange"><strong>struct</strong></span>.</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a></a><span class="bu">Base</span>.<span class="pp">@kwdef</span> <span class="kw">struct</span> ConsumptionSavingsDT</span>
<span id="cb6-2"><a></a>    γ<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">2.0</span>        <span class="co"># CRRA coefficient</span></span>
<span id="cb6-3"><a></a>    ρ<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">0.05</span>       <span class="co"># discount rate</span></span>
<span id="cb6-4"><a></a>    A<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">1.00</span>       <span class="co"># terminal value function parameter</span></span>
<span id="cb6-5"><a></a>    R<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fu">exp</span>(ρ)     <span class="co"># interest rate</span></span>
<span id="cb6-6"><a></a>    σ<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">0.25</span>       <span class="co"># standard deviation of log income</span></span>
<span id="cb6-7"><a></a>    Z<span class="op">::</span><span class="dt">NamedTuple </span><span class="op">=</span> <span class="fu">tauchen</span>(<span class="fl">9</span>, <span class="fl">0.0</span>, σ) <span class="co"># income process</span></span>
<span id="cb6-8"><a></a>    Y<span class="op">::</span><span class="dt">Vector{Float64} </span><span class="op">=</span> <span class="fu">exp</span>.(Z.z)  <span class="co"># income levels</span></span>
<span id="cb6-9"><a></a>    N<span class="op">::</span><span class="dt">Int64  </span><span class="op">=</span> <span class="fl">11</span>          <span class="co"># number of grid points</span></span>
<span id="cb6-10"><a></a>    α<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">0.0</span>        <span class="co"># grid spacing parameter</span></span>
<span id="cb6-11"><a></a>    Mgrid<span class="op">::</span><span class="dt">Vector{Float64} </span><span class="op">=</span> <span class="fu">make_grid</span>(<span class="fl">0.0</span>, <span class="fl">2.5</span>, N; α <span class="op">=</span> α)</span>
<span id="cb6-12"><a></a>    agrid<span class="op">::</span><span class="dt">Vector{Float64} </span><span class="op">=</span> <span class="fu">make_grid</span>(<span class="fl">0.0</span>, <span class="fl">1.0</span>, N; α <span class="op">=</span> α)</span>
<span id="cb6-13"><a></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="fragment">
<p>The struct stores the parameters and grids for the model.</p>
<ul>
<li>This lets us pass the entire model cleanly between solvers, simulators, and calibration routines</li>
<li>Makes it easy to override the baseline calibration via keyword arguments</li>
</ul>
<div id="8" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb7-1"><a></a>m1 <span class="op">=</span> <span class="fu">ConsumptionSavingsDT</span>()</span>
<span id="cb7-2"><a></a><span class="fu">println</span>(<span class="st">"Risk aversion in model 1: </span><span class="sc">$</span>(m1.γ)<span class="st">"</span>, <span class="st">" | "</span>, <span class="st">"Discount rate in model 1: </span><span class="sc">$</span>(m1.ρ)<span class="st">"</span>)</span>
<span id="cb7-3"><a></a></span>
<span id="cb7-4"><a></a>m2 <span class="op">=</span> <span class="fu">ConsumptionSavingsDT</span>(γ <span class="op">=</span> <span class="fl">1.5</span>)</span>
<span id="cb7-5"><a></a><span class="fu">println</span>(<span class="st">"Risk aversion in model 2: </span><span class="sc">$</span>(m2.γ)<span class="st">"</span>, <span class="st">" | "</span>, <span class="st">"Discount rate in model 2: </span><span class="sc">$</span>(m2.ρ)<span class="st">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>Risk aversion in model 1: 2.0 | Discount rate in model 1: 0.05
Risk aversion in model 2: 1.5 | Discount rate in model 2: 0.05</code></pre>
</div>
</div>
</div>
</section>
<section id="one-step-value-function-iteration" class="slide level2 compact-slide">
<h2>One-step Value Function Iteration</h2>
<p>We now solve for <span class="math inline">\(V_1(M)\)</span> and <span class="math inline">\(c_1(M)\)</span>, given the terminal condition <span class="math inline">\(V_0(M) = \frac{M^{1-\gamma}}{1-\gamma}\)</span>.</p>
<ul>
<li>We start with the <em>brute-force</em> approach.</li>
<li>We discretize the control space into <span class="math inline">\(N_c\)</span> points and choose the maximizer of the action-value function.</li>
</ul>
<div class="fragment">
<p>We need to specify the <em>admissible consumption set</em>.</p>
<ul>
<li>The lower bound is naturally <span class="math inline">\(c=0\)</span>.</li>
<li>For the upper bound, feasibility requires that next period’s cash-on-hand be nonnegative for all realizations of <span class="math inline">\(Y'\)</span>: <span class="math display">\[
c_{\max}(M) = M + \frac{Y_{\min}}{R},
\]</span> since choosing <span class="math inline">\(c=c_{\max}(M)\)</span> leaves <span class="math inline">\(M' = R(M-c) + Y_{\min} = 0\)</span> next period.</li>
</ul>
</div>
<div class="fragment">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="vf-iteration-code" data-code-line-numbers="1-11|2|3-4|5-6|7-9|10"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="vf-iteration-code-1"><a href="#vf-iteration-code-1"></a><span class="kw">function</span> <span class="fu">vf_iteration</span>(m<span class="op">::</span><span class="dt">ConsumptionSavingsDT</span>, V0<span class="op">::</span><span class="dt">Function</span>; NM<span class="op">::</span><span class="dt">Int64 </span><span class="op">=</span> <span class="fl">11</span>, Nc<span class="op">::</span><span class="dt">Int64 </span><span class="op">=</span> <span class="fl">101</span>)</span>
<span id="vf-iteration-code-2"><a href="#vf-iteration-code-2"></a>    (; Y, Z, R, γ, ρ) <span class="op">=</span> m <span class="co"># unpack model parameters</span></span>
<span id="vf-iteration-code-3"><a href="#vf-iteration-code-3"></a>    Mgrid <span class="op">=</span> <span class="fu">collect</span>(<span class="fu">range</span>(<span class="op">-</span>Y[<span class="fl">1</span>]<span class="op">/</span>R, <span class="fl">3.0</span>, length<span class="op">=</span>NM)) <span class="co"># grid for M</span></span>
<span id="vf-iteration-code-4"><a href="#vf-iteration-code-4"></a>    cgrid <span class="op">=</span> [<span class="fu">range</span>(<span class="fl">0.0</span>, m <span class="op">+</span> Y[<span class="fl">1</span>]<span class="op">/</span>R, length<span class="op">=</span>Nc) for m <span class="kw">in</span> Mgrid] <span class="co"># collection of grids for c</span></span>
<span id="vf-iteration-code-5"><a href="#vf-iteration-code-5"></a>    <span class="co"># Action-value function</span></span>
<span id="vf-iteration-code-6"><a href="#vf-iteration-code-6"></a>    <span class="fu">V1</span>(M, c) <span class="op">=</span> c<span class="op">^</span>(<span class="fl">1</span><span class="op">-</span>γ)<span class="op">/</span>(<span class="fl">1</span><span class="op">-</span>γ) <span class="op">+</span> <span class="fu">exp</span>(<span class="op">-</span>ρ) <span class="op">*</span> <span class="fu">sum</span>(Z.P[<span class="fl">1</span>,j] <span class="op">*</span> <span class="fu">V0</span>(m,R <span class="op">*</span> (M<span class="op">-</span>c) <span class="op">+</span> Y[j]<span class="op">+</span><span class="fl">1e-12</span>) <span class="cf">for</span> j <span class="kw">in</span> <span class="fu">eachindex</span>(Y))</span>
<span id="vf-iteration-code-7"><a href="#vf-iteration-code-7"></a>    <span class="co"># Policy and value functions</span></span>
<span id="vf-iteration-code-8"><a href="#vf-iteration-code-8"></a>    C <span class="op">=</span> [cgrid[j][<span class="fu">argmax</span>([<span class="fu">V1</span>(Mgrid[j], c) for c <span class="kw">in</span> cgrid[j]])] for j <span class="kw">in</span> <span class="fu">eachindex</span>(Mgrid)] </span>
<span id="vf-iteration-code-9"><a href="#vf-iteration-code-9"></a>    V <span class="op">=</span> [<span class="fu">V1</span>(Mgrid[j], C[j]) for j <span class="kw">in</span> <span class="fu">eachindex</span>(Mgrid)]</span>
<span id="vf-iteration-code-10"><a href="#vf-iteration-code-10"></a>    <span class="cf">return</span> (; C, V, Mgrid) <span class="co"># return a named tuple</span></span>
<span id="vf-iteration-code-11"><a href="#vf-iteration-code-11"></a><span class="cf">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="policy-and-value-functions" class="slide level2 compact-slide">
<h2>Policy and Value Functions</h2>
<p>Two theoretical bounds for the policy function:</p>
<ul>
<li><p>Lower bound: household receives the <em>lowest</em> income with certainty.</p></li>
<li><p>Upper bound: household receives the <em>average</em> income with certainty.</p></li>
</ul>
<div class="fragment">
<div class="columns">
<div class="column" style="width:50%;">
<p><img data-src="Figures/p_vf1a.png" style="width:100.0%"></p>
<p style="text-align: center; color: #555555; font-weight: bold;">
a) Policy functions
</p>
</div><div class="column" style="width:50%;">
<p><img data-src="Figures/p_vf1b.png" style="width:100.0%"></p>
<p style="text-align: center; color: #555555; font-weight: bold;">
b) Value functions
</p>
</div></div>
</div>
</section>
<section id="the-marginal-propensity-to-consume" class="slide level2 compact-slide">
<h2>The Marginal Propensity to Consume</h2>
<p>Given the policy function <span class="math inline">\(c_t(M)\)</span>, we can obtain the marginal propensity to consume (MPC).</p>
<ul>
<li>The MPC measures the change in consumption for a change in <span class="math inline">\(M\)</span>: <span class="math inline">\(MPC(M) = \frac{d c_t(M)}{d M}\)</span>.</li>
</ul>
<div class="fragment">
<p><span class="citation" data-cites="CarrollKimball1996">Carroll and Kimball (<a href="#/references" role="doc-biblioref" onclick="">1996</a>)</span> show that the MPC is decreasing in <span class="math inline">\(M\)</span>.</p>
<ul>
<li>But the numerical solution does not necessarily satisfy this property.</li>
</ul>
<div class="columns">
<div class="column" style="width:50%;">
<p><img data-src="Figures/p_vf2a.png" style="width:100.0%"></p>
<p style="text-align: center; color: #555555; font-weight: bold;">
a) MPCs for <span class="math inline">\(N_M = 11\)</span>
</p>
</div><div class="column" style="width:50%;">
<p><img data-src="Figures/p_vf2b.png" style="width:100.0%"></p>
<p style="text-align: center; color: #555555; font-weight: bold;">
b) MPCs for <span class="math inline">\(N_M = 101\)</span>
</p>
</div></div>
</div>
</section>
<section id="the-egm-step" class="slide level2 compact-slide">
<h2>The EGM Step</h2>
<p>We now solve for the value and policy functions using the endogenous gridpoint method (EGM).</p>
<ul>
<li><p>This approaches approximates the policy function directly, rather than the value function.</p></li>
<li><p>We focus on the case the household can borrow up to the <em>natural borrowing limit</em>.</p></li>
</ul>
<p>The limit varies with the horizon: <span class="math inline">\(a_T(M) \geq \underline{a}_T\)</span>: <span class="math display">\[
  \underline{a}_T = -\sum_{t=1}^{T} \frac{Y_{\min}}{R^t}.
\]</span></p>
<p>We work with the transformed grid: <span class="math display">\[
  \tilde{a}_t(M) = a_t(M) - \underline{a}_t,
\]</span></p>
<div class="fragment">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="egm-step-code" data-code-line-numbers="1-10|3|4-6|7|8-9"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="egm-step-code-1"><a href="#egm-step-code-1"></a><span class="kw">function</span> <span class="fu">egm_step</span>(m<span class="op">::</span><span class="dt">ConsumptionSavingsDT</span>, iter<span class="op">::</span><span class="dt">Int</span>, c0<span class="op">::</span><span class="dt">Function</span>)</span>
<span id="egm-step-code-2"><a href="#egm-step-code-2"></a>    (; agrid, Z, Y, R, γ, ρ) <span class="op">=</span> m <span class="co"># unpack model parameters</span></span>
<span id="egm-step-code-3"><a href="#egm-step-code-3"></a>    agrid_shifted <span class="op">=</span> <span class="op">-</span>Y[<span class="fl">1</span>] <span class="op">*</span> <span class="fu">sum</span>(R<span class="op">.^</span>(<span class="fu">-</span>(<span class="fl">1</span><span class="op">:</span>iter))) <span class="op">.+</span> agrid </span>
<span id="egm-step-code-4"><a href="#egm-step-code-4"></a>    <span class="co"># compute the consumption policy</span></span>
<span id="egm-step-code-5"><a href="#egm-step-code-5"></a>    c1 <span class="op">=</span> [<span class="fu">sum</span>(<span class="fu">exp</span>(<span class="op">-</span>ρ) <span class="op">*</span> Z.P[<span class="fl">1</span>,j] <span class="op">*</span> R <span class="op">*</span> <span class="fu">c0</span>(R <span class="op">*</span> a <span class="op">+</span> Y[j]<span class="op">+</span><span class="fl">1e-12</span>)<span class="op">^</span>(<span class="op">-</span>γ) </span>
<span id="egm-step-code-6"><a href="#egm-step-code-6"></a>        for j <span class="kw">in</span> <span class="fu">eachindex</span>(Y))<span class="op">^</span>(<span class="op">-</span><span class="fl">1</span><span class="op">/</span>γ) for a <span class="kw">in</span> agrid_shifted] </span>
<span id="egm-step-code-7"><a href="#egm-step-code-7"></a>    M1 <span class="op">=</span> agrid_shifted <span class="op">.+</span> c1 <span class="co"># compute the cash-on-hand</span></span>
<span id="egm-step-code-8"><a href="#egm-step-code-8"></a>    <span class="cf">return</span> (; c <span class="op">=</span> <span class="fu">linear_interpolation</span>(M1, c1; </span>
<span id="egm-step-code-9"><a href="#egm-step-code-9"></a>        extrapolation_bc<span class="op">=</span><span class="fu">Line</span>()), M <span class="op">=</span> M1)</span>
<span id="egm-step-code-10"><a href="#egm-step-code-10"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="the-egm-iteration" class="slide level2 compact-slide">
<h2>The EGM Iteration</h2>
<p>We iterate the EGM step until the policy function converges.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="egm-iteration-code" data-code-line-numbers="1-10|2|3|4-6|1-10"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="egm-iteration-code-1"><a href="#egm-iteration-code-1"></a><span class="co"># Endogenous gridpoint method iteration</span></span>
<span id="egm-iteration-code-2"><a href="#egm-iteration-code-2"></a>m <span class="op">=</span> <span class="fu">ConsumptionSavingsDT</span>(N <span class="op">=</span> <span class="fl">100</span>, α <span class="op">=</span> <span class="fl">1.5</span>)</span>
<span id="egm-iteration-code-3"><a href="#egm-iteration-code-3"></a>policies <span class="op">=</span> [<span class="fu">egm_step</span>(m, <span class="fl">1</span>, M<span class="op">-&gt;</span>M)]</span>
<span id="egm-iteration-code-4"><a href="#egm-iteration-code-4"></a><span class="cf">for</span> i <span class="op">=</span> <span class="fl">2</span><span class="op">:</span><span class="fl">8</span></span>
<span id="egm-iteration-code-5"><a href="#egm-iteration-code-5"></a>    <span class="fu">push!</span>(policies, <span class="fu">egm_step</span>(m, i, M<span class="op">-&gt;</span>policies[i<span class="op">-</span><span class="fl">1</span>][<span class="fl">1</span>](M)))</span>
<span id="egm-iteration-code-6"><a href="#egm-iteration-code-6"></a><span class="cf">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="fragment">
<p>We can compute the marginal propensity to consume (MPC) using the <em>finite-difference</em> method.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="fd-derivative-code" data-code-line-numbers="1-10"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="fd-derivative-code-1"><a href="#fd-derivative-code-1"></a><span class="co"># Compute finite difference derivative</span></span>
<span id="fd-derivative-code-2"><a href="#fd-derivative-code-2"></a><span class="kw">function</span> <span class="fu">fd_derivative</span>(grid, x)</span>
<span id="fd-derivative-code-3"><a href="#fd-derivative-code-3"></a>    x_interp <span class="op">=</span> <span class="fu">linear_interpolation</span>(grid, x)</span>
<span id="fd-derivative-code-4"><a href="#fd-derivative-code-4"></a>    <span class="cf">return</span> [Interpolations.<span class="fu">gradient</span>(x_interp, x)[<span class="fl">1</span>] for x <span class="kw">in</span> grid]</span>
<span id="fd-derivative-code-5"><a href="#fd-derivative-code-5"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div class="fragment">
<div class="columns">
<div class="column" style="width:50%;">
<p><img data-src="Figures/p_vf3a.png" style="width:100.0%"></p>
<p style="text-align: center; color: #555555; font-weight: bold;">
a) Policy function
</p>
</div><div class="column" style="width:50%;">
<p><img data-src="Figures/p_vf3b.png" style="width:100.0%"></p>
<p style="text-align: center; color: #555555; font-weight: bold;">
b) Marginal propensity to consume
</p>
</div></div>
</div>
</section></section>
<section>
<section id="iv.-the-challenge-of-high-dimensional-problems" class="title-slide slide level1 center">
<h1>IV. The Challenge of High-Dimensional Problems</h1>

</section>
<section id="the-three-curses-of-dimensionality-revisited" class="slide level2 compact-slide">
<h2>The Three Curses of Dimensionality Revisited</h2>
<p>The methods discussed in this module are the backbone of modern computational economics.</p>
<ul>
<li>They are very effective in one or two dimensions.</li>
<li>However, they suffer from the <em>three curses of dimensionality</em>.</li>
</ul>
<div class="fragment">
<p><span class="text-blue"><strong>1) The curse of representation</strong></span></p>
<ul>
<li>We represented the value and policy functions on a grid.</li>
<li>The number of grid points grows exponentially with the number of state variables.</li>
</ul>
</div>
<div class="fragment">
<p><span class="text-orange"><strong>2) The curse of optimization</strong></span></p>
<ul>
<li>The EGM method enable us to avoid the costly root-finding step with a single control variable.</li>
<li>But this only works seamlessly in the case of a single control variable.</li>
</ul>
</div>
<div class="fragment">
<p><span class="text-green"><strong>3) The curse of expectation</strong></span></p>
<ul>
<li>We computed expectations using the <em>Tauchen</em> method.</li>
<li>The Markov chain approximation becomes increasingly costly with more shocks</li>
</ul>
</div>
</section>
<section id="the-way-forward" class="slide level2 compact-slide">
<h2>The Way Forward</h2>
<p>The techniques discussed in this module suffer from the three curses of dimensionality.</p>
<ul>
<li>Overcoming these limitations requires new tools.</li>
</ul>
<div style="margin-top: 1.5em;">

</div>
<p>We will rely on a combination of two main ingredients:</p>
<ul>
<li><span class="text-orange"><strong>Continuous-time</strong></span> methods combined with <span class="text-green"><strong>machine learning</strong></span> techniques.</li>
</ul>
<div style="margin-top: 1.5em;">

</div>
<p>Before jumping into machine learning, we discuss next <em>continuous-time methods</em>.</p>
</section>
<section id="references" class="slide level2 compact-slide smaller scrollable">
<h2>References</h2>
<div class="references">

</div>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Carroll2006" class="csl-entry" role="listitem">
Carroll, Christopher D. 2006. <span>“The Method of Endogenous Gridpoints for Solving Dynamic Stochastic Optimization Problems.”</span> <em>Economics Letters</em> 91 (3): 312–20. <a href="https://doi.org/10.1016/j.econlet.2005.09.013">https://doi.org/10.1016/j.econlet.2005.09.013</a>.
</div>
<div id="ref-CarrollKimball1996" class="csl-entry" role="listitem">
Carroll, Christopher D., and Miles S. Kimball. 1996. <span>“On the Concavity of the Consumption Function.”</span> <em>Econometrica</em> 64 (4): 981–92. <a href="https://doi.org/10.2307/2171853">https://doi.org/10.2307/2171853</a>.
</div>
<div id="ref-Rouwenhorst1995" class="csl-entry" role="listitem">
Rouwenhorst, K. Geert. 1995. <span>“Asset Pricing Implications of Equilibrium Business Cycle Models.”</span> In <em>Frontiers of Business Cycle Research</em>, edited by Thomas F. Cooley, 294–330. Princeton, NJ: Princeton University Press.
</div>
<div id="ref-TauchenHussey1991" class="csl-entry" role="listitem">
Tauchen, George, and Robert Hussey. 1991. <span>“Quadrature-Based Methods for Obtaining Approximate Solutions to Nonlinear Asset Pricing Models.”</span> <em>Econometrica</em> 59 (2): 371–96. <a href="https://doi.org/10.2307/2938261">https://doi.org/10.2307/2938261</a>.
</div>
</div>
</section></section>
    </div>
  <div class="quarto-auto-generated-content" style="display: none;">
<div class="footer footer-default">

</div>
</div></div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="../site_libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="../site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="../site_libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="../site_libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="../site_libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="../site_libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="../site_libs/revealjs/plugin/notes/notes.js"></script>
  <script src="../site_libs/revealjs/plugin/search/search.js"></script>
  <script src="../site_libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="../site_libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': true,
'previewLinksAuto': false,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'jumpToSlide': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleScrollView(event)\"><kbd>r</kbd> Scroll View Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"5\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":true},
'smaller': false,
 
        // Display controls in the bottom right corner
        controls: false,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'none',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1050,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        math: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@2.7.9/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, QuartoSupport,

          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script>
    function greyOutPreviousFragments(slide) {
      if (!slide || slide.dataset.greyPrevious !== 'true') return;
      
      const fragments = Array
        .from(slide.querySelectorAll('.fragment[data-fragment-index]'))
        .sort(
          (a, b) =>
            (Number(a.dataset.fragmentIndex) || 0) -
            (Number(b.dataset.fragmentIndex) || 0)
        );
      
      if (!fragments.length) return;
      
      fragments.forEach(frag => {
        frag.style.transition = 'opacity 0.8s ease-in-out, color 0.8s ease-in-out';
      });
      
      const visibleFragments = fragments.filter(frag =>
        frag.classList.contains('visible') ||
        frag.classList.contains('current-fragment')
      );
      const maxVisibleIndex = visibleFragments.length
        ? Math.max(
            ...visibleFragments.map(frag => Number(frag.dataset.fragmentIndex) || 0)
          )
        : -1;
      
      fragments.forEach(frag => {
        const fragIndex = Number(frag.dataset.fragmentIndex) || 0;
        if (fragIndex < maxVisibleIndex) {
          frag.style.opacity = '0.4';
          frag.style.color = '#808080';
        } else {
          frag.style.opacity = '1';
          frag.style.color = '';
        }
      });
    }

    Reveal.addEventListener('slidechanged', function(event) {
      setTimeout(() => greyOutPreviousFragments(event.currentSlide), 100);
    });

    Reveal.addEventListener('fragmentshown', function(event) {
      const slide = event.fragment.closest('section');
      setTimeout(() => greyOutPreviousFragments(slide), 50);
    });

    Reveal.addEventListener('fragmenthidden', function(event) {
      const slide = event.fragment.closest('section');
      setTimeout(() => greyOutPreviousFragments(slide), 50);
    });

    // Also check on initial load
    Reveal.addEventListener('ready', function(event) {
      setTimeout(() => {
        document
          .querySelectorAll('section[data-grey-previous="true"]')
          .forEach(slide => greyOutPreviousFragments(slide));
      }, 100);
    });

    // Add line-by-line highlighting to code blocks
    function setupLineByLineHighlighting() {
      const allPre = document.querySelectorAll('pre code');
      allPre.forEach(code => {
        const pre = code.parentElement;
        if (pre && pre.tagName === 'PRE' && !pre.dataset.lineNumbersSetup) {
          let lineNumbers = null;
          
          // Check for vf_iteration function
          if (code.textContent.includes('function vf_iteration')) {
            lineNumbers = '1|2|3|4|5|6|7|8|9|10|11|12|13|14|15';
          }
          // Check for tauchen function
          else if (code.textContent.includes('function tauchen')) {
            lineNumbers = '1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32';
          }
          
          if (lineNumbers) {
            // Set data-line-numbers attribute (Reveal.js should handle this)
            pre.setAttribute('data-line-numbers', lineNumbers);
            
            // Add CSS for line highlighting (fallback if plugin doesn't work)
            if (!document.getElementById('line-highlight-style')) {
              const style = document.createElement('style');
              style.id = 'line-highlight-style';
              style.textContent = `
                pre[data-line-numbers] code {
                  counter-reset: line;
                }
                pre[data-line-numbers] code .hljs-line::before {
                  counter-increment: line;
                  content: counter(line);
                  display: inline-block;
                  width: 2em;
                  padding-right: 1em;
                  color: #999;
                  text-align: right;
                }
                /* Highlight current line based on fragment */
                pre[data-line-numbers] code .hljs-line.fragment.visible {
                  background-color: rgba(255, 255, 0, 0.2);
                }
              `;
              document.head.appendChild(style);
            }
            
            console.log('Set data-line-numbers attribute on code block');
            pre.dataset.lineNumbersSetup = 'true';
          }
        }
      });
    }

    // Try multiple times to catch the code when it's rendered
    function trySetupLineNumbers() {
      setupLineByLineHighlighting();
      setTimeout(setupLineByLineHighlighting, 200);
      setTimeout(setupLineByLineHighlighting, 500);
      setTimeout(setupLineByLineHighlighting, 1000);
      setTimeout(setupLineByLineHighlighting, 2000);
    }

    Reveal.addEventListener('ready', function(event) {
      console.log('Reveal.js ready, setting up line numbers');
      trySetupLineNumbers();
    });

    Reveal.addEventListener('slidechanged', function(event) {
      setTimeout(setupLineByLineHighlighting, 200);
    });

    // Also use MutationObserver to catch when code is added
    const observer = new MutationObserver(function(mutations) {
      setupLineByLineHighlighting();
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true
    });

    // Add footer with link back to homepage
    function addHomepageFooter() {
      // Check if footer already exists
      if (document.getElementById('homepage-footer')) return;
      
      // All slides are in Module subdirectories, so go up one level to reach index.html
      const homePath = '../index.html';
      
      // Create footer element
      const footer = document.createElement('div');
      footer.id = 'homepage-footer';
      footer.innerHTML = '<a href="' + homePath + '" title="Back to homepage">🏠</a>';
      
      // Add to reveal container
      const revealContainer = document.querySelector('.reveal');
      if (revealContainer) {
        revealContainer.appendChild(footer);
      }
    }

    // Add footer when Reveal is ready
    if (typeof Reveal !== 'undefined') {
      Reveal.addEventListener('ready', function(event) {
        addHomepageFooter();
      });
    } else {
      // Fallback: wait for Reveal to be available
      window.addEventListener('load', function() {
        if (typeof Reveal !== 'undefined') {
          Reveal.addEventListener('ready', function(event) {
            addHomepageFooter();
          });
          // Try immediately in case Reveal is already ready
          setTimeout(addHomepageFooter, 100);
        }
      });
    }
    </script>

    <style>
    /* Footer with link back to homepage */
    .reveal #homepage-footer {
      position: fixed;
      bottom: 20px;
      right: 70px;
      z-index: 1000;
      font-size: 0.5em;
      opacity: 0.5;
      transition: opacity 0.3s ease;
    }

    .reveal #homepage-footer:hover {
      opacity: 1;
    }

    .reveal #homepage-footer a {
      color: #0072b2;
      text-decoration: none;
      padding: 3px 5px;
      background-color: rgba(255, 255, 255, 0.9);
      border-radius: 3px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      display: inline-block;
      transition: background-color 0.3s ease, transform 0.2s ease;
      line-height: 1;
    }

    .reveal #homepage-footer a:hover {
      background-color: #0072b2;
      transform: scale(1.1);
      text-decoration: none;
    }

    /* Hide footer on title slide if desired */
    .reveal #title-slide ~ #homepage-footer,
    .reveal section#title-slide ~ #homepage-footer {
      display: none;
    }
    </style>

    <script id="quarto-html-after-body" type="application/javascript">
      window.document.addEventListener("DOMContentLoaded", function (event) {
        const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
        tabsets.forEach(function(tabset) {
          const tabby = new Tabby('#' + tabset.id);
        });
        const isCodeAnnotation = (el) => {
          for (const clz of el.classList) {
            if (clz.startsWith('code-annotation-')) {                     
              return true;
            }
          }
          return false;
        }
        const onCopySuccess = function(e) {
          // button target
          const button = e.trigger;
          // don't keep focus
          button.blur();
          // flash "checked"
          button.classList.add('code-copy-button-checked');
          var currentTitle = button.getAttribute("title");
          button.setAttribute("title", "Copied!");
          let tooltip;
          if (window.bootstrap) {
            button.setAttribute("data-bs-toggle", "tooltip");
            button.setAttribute("data-bs-placement", "left");
            button.setAttribute("data-bs-title", "Copied!");
            tooltip = new bootstrap.Tooltip(button, 
              { trigger: "manual", 
                customClass: "code-copy-button-tooltip",
                offset: [0, -8]});
            tooltip.show();    
          }
          setTimeout(function() {
            if (tooltip) {
              tooltip.hide();
              button.removeAttribute("data-bs-title");
              button.removeAttribute("data-bs-toggle");
              button.removeAttribute("data-bs-placement");
            }
            button.setAttribute("title", currentTitle);
            button.classList.remove('code-copy-button-checked');
          }, 1000);
          // clear code selection
          e.clearSelection();
        }
        const getTextToCopy = function(trigger) {
          const outerScaffold = trigger.parentElement.cloneNode(true);
          const codeEl = outerScaffold.querySelector('code');
          for (const childEl of codeEl.children) {
            if (isCodeAnnotation(childEl)) {
              childEl.remove();
            }
          }
          return codeEl.innerText;
        }
        const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
          text: getTextToCopy
        });
        clipboard.on('success', onCopySuccess);
        if (window.document.getElementById('quarto-embedded-source-code-modal')) {
          const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
            text: getTextToCopy,
            container: window.document.getElementById('quarto-embedded-source-code-modal')
          });
          clipboardModal.on('success', onCopySuccess);
        }
          var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
          var mailtoRegex = new RegExp(/^mailto:/);
            var filterRegex = new RegExp('/' + window.location.host + '/');
          var isInternal = (href) => {
              return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
          }
          // Inspect non-navigation links and adorn them if external
         var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
          for (var i=0; i<links.length; i++) {
            const link = links[i];
            if (!isInternal(link.href)) {
              // undo the damage that might have been done by quarto-nav.js in the case of
              // links that we want to consider external
              if (link.dataset.originalHref !== undefined) {
                link.href = link.dataset.originalHref;
              }
            }
          }
        function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
          const config = {
            allowHTML: true,
            maxWidth: 500,
            delay: 100,
            arrow: false,
            appendTo: function(el) {
                return el.closest('section.slide') || el.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'light-border',
            placement: 'bottom-start',
          };
          if (contentFn) {
            config.content = contentFn;
          }
          if (onTriggerFn) {
            config.onTrigger = onTriggerFn;
          }
          if (onUntriggerFn) {
            config.onUntrigger = onUntriggerFn;
          }
            config['offset'] = [0,0];
            config['maxWidth'] = 700;
          window.tippy(el, config); 
        }
        const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
        for (var i=0; i<noterefs.length; i++) {
          const ref = noterefs[i];
          tippyHover(ref, function() {
            // use id or data attribute instead here
            let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
            try { href = new URL(href).hash; } catch {}
            const id = href.replace(/^#\/?/, "");
            const note = window.document.getElementById(id);
            if (note) {
              return note.innerHTML;
            } else {
              return "";
            }
          });
        }
        const findCites = (el) => {
          const parentEl = el.parentElement;
          if (parentEl) {
            const cites = parentEl.dataset.cites;
            if (cites) {
              return {
                el,
                cites: cites.split(' ')
              };
            } else {
              return findCites(el.parentElement)
            }
          } else {
            return undefined;
          }
        };
        var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
        for (var i=0; i<bibliorefs.length; i++) {
          const ref = bibliorefs[i];
          const citeInfo = findCites(ref);
          if (citeInfo) {
            tippyHover(citeInfo.el, function() {
              var popup = window.document.createElement('div');
              citeInfo.cites.forEach(function(cite) {
                var citeDiv = window.document.createElement('div');
                citeDiv.classList.add('hanging-indent');
                citeDiv.classList.add('csl-entry');
                var biblioDiv = window.document.getElementById('ref-' + cite);
                if (biblioDiv) {
                  citeDiv.innerHTML = biblioDiv.innerHTML;
                }
                popup.appendChild(citeDiv);
              });
              return popup.innerHTML;
            });
          }
        }
      });
      </script>
    

</body></html>
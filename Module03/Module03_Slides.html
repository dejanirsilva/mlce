<!DOCTYPE html>
<html lang="en"><head>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-html/tabby.min.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/light-border.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.8.25">

  <meta name="author" content="Dejanir Silva">
  <title>Machine Learning for Computational Economics</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="../site_libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="../site_libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      { color: #003b4f; background-color: #f1f3f5; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #003b4f; } /* Normal */
    code span.al { color: #ad0000; } /* Alert */
    code span.an { color: #5e5e5e; } /* Annotation */
    code span.at { color: #657422; } /* Attribute */
    code span.bn { color: #ad0000; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #003b4f; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #20794d; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #5e5e5e; } /* Comment */
    code span.cv { color: #5e5e5e; font-style: italic; } /* CommentVar */
    code span.do { color: #5e5e5e; font-style: italic; } /* Documentation */
    code span.dt { color: #ad0000; } /* DataType */
    code span.dv { color: #ad0000; } /* DecVal */
    code span.er { color: #ad0000; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #ad0000; } /* Float */
    code span.fu { color: #4758ab; } /* Function */
    code span.im { color: #00769e; } /* Import */
    code span.in { color: #5e5e5e; } /* Information */
    code span.kw { color: #003b4f; font-weight: bold; } /* Keyword */
    code span.op { color: #5e5e5e; } /* Operator */
    code span.ot { color: #003b4f; } /* Other */
    code span.pp { color: #ad0000; } /* Preprocessor */
    code span.sc { color: #5e5e5e; } /* SpecialChar */
    code span.ss { color: #20794d; } /* SpecialString */
    code span.st { color: #20794d; } /* String */
    code span.va { color: #111111; } /* Variable */
    code span.vs { color: #20794d; } /* VerbatimString */
    code span.wa { color: #5e5e5e; font-style: italic; } /* Warning */
    /* CSS for citations */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
      margin-bottom: 0em;
    }
    .hanging-indent div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }  </style>
  <link rel="stylesheet" href="../site_libs/revealjs/dist/theme/quarto-cfda842e1c2da8cd79357d57ebaa6bca.css">
  <link href="../site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="../site_libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
</head>
<body class="quarto-light">
  <div class="reveal">
    <div class="slides">

<section id="title-slide" class="quarto-title-block center">
  <h1 class="title">Machine Learning for Computational Economics</h1>
  <p class="subtitle"><span class="module-name">Module 03: Continuous-Time Methods</span><br><span class="school-name">EDHEC Business School</span></p>

<div class="quarto-title-authors">
<div class="quarto-title-author">
<div class="quarto-title-author-name">
Dejanir Silva 
</div>
        <p class="quarto-title-affiliation">
            Purdue University
          </p>
    </div>
</div>

  <p class="date">January 2026</p>
</section>
<section id="introduction" class="slide level2 compact-slide">
<h2>Introduction</h2>
<p><span class="text-orange"><strong>Continuous-time</strong></span> formulations provide an elegant counterpart to discrete-time dynamic programming.</p>
<ul>
<li>Instead of expectations over future states, they express optimal behavior through <em>differential operators</em>.</li>
<li>The solution is characterized by a <em>partial differential equation</em> (PDE).</li>
</ul>
<div style="margin-top: 1.5em;">

</div>
<p>In this module, we revisit the <span class="text-blue"><strong>consumption-savings problem</strong></span> from Module 02.</p>
<ul>
<li>We show how to derive the <em>Hamilton-Jacobi-Bellman (HJB)</em> equation.</li>
<li>We solve the HJB equation numerically using <em>finite-difference schemes</em> and <em>spectral methods</em>.</li>
</ul>
<div style="margin-top: 1.5em;">

</div>
<p>The module is organized as follows:</p>
<ol type="1">
<li>Derivation of the HJB equation.</li>
<li>Solution and stability of finite-difference schemes.</li>
<li>Application of spectral methods.</li>
</ol>
</section>
<section>
<section id="i.-from-discrete-to-continuous-time" class="title-slide slide level1 center">
<h1>I. From Discrete to Continuous Time</h1>

</section>
<section id="a-portfolio-choice-problem-with-uninsurable-income" class="slide level2 compact-slide">
<h2>A Portfolio Choice Problem with Uninsurable Income</h2>
<p>We extend the consumption-savings problem from Module 02 in two dimensions:</p>
<ol type="1">
<li>The household faces a <em>portfolio choice problem</em>: she decides how much to save in a safe and a risky asset.</li>
<li>Labor income follows a <em>persistent Markov process</em> rather than being i.i.d. over time.</li>
</ol>
<div class="columns">
<div class="column fragment" style="width:50%;">
<p><span class="text-blue"><strong>Asset returns:</strong></span></p>
<p>Riskless return over a small interval <span class="math inline">\(\Delta t\)</span> is <span class="math display">\[
  R_f = 1 + r\,\Delta t,
\]</span> and the return on the risky asset is: <span class="math display">\[
  R_{r,t+\Delta t} = 1 + \mu_r\,\Delta t + \sigma_r \sqrt{\Delta t}\,\varepsilon_{r,t+\Delta t},
\]</span> where <span class="math inline">\(\varepsilon_{r,t+\Delta t}\)</span> is a unit-variance white noise.</p>
</div><div class="column fragment" style="width:50%;">
<p><span class="text-green"><strong>Labor income:</strong></span></p>
<p>Labor income follows a (discrete-state) Markov chain: <span class="math display">\[
  Y_t \in \{Y_1, \ldots, Y_{N_y}\},
\]</span> with transition probabilities <span class="math display">\[
  P_{ij} = \lambda_{ij}\,\Delta t, \qquad j \neq i,
\]</span> and <span class="math inline">\(P_{ii} = 1 - \sum_{j \neq i} P_{ij}\)</span>.</p>
</div></div>
<div class="fragment">
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Note</strong></p>
</div>
<div class="callout-content">
<p>The scaling ensures that mean and variance of the risky return are of order <span class="math inline">\(\Delta t\)</span>. To see this, fix a horizon <span class="math inline">\(T = n\,\Delta t\)</span> and note that <span class="math display">\[
    \operatorname{Var}\!\left[\sum_{k=1}^{n} R_{r,t+k\Delta t}\right]
    = n\,\sigma_r^2\,\Delta t
    = \sigma_r^2\,T.
  \]</span> Hence, as we partition the time interval into finer and finer subperiods, the total amount of risk over <span class="math inline">\([t,\,t+T]\)</span> remains unchanged.</p>
</div>
</div>
</div>
</div>
</section>
<section id="the-bellman-equation-with-time-step-delta-t" class="slide level2 compact-slide">
<h2>The Bellman Equation with Time Step <span class="math inline">\(\Delta t\)</span></h2>
<p>The Bellman equation for this discrete-time formulation is <span class="math display">\[
  V_t(W, Y) = \max_{c, \alpha} \left\{ u(c)\,\Delta t + e^{-\rho \Delta t}\, \mathbb{E}\left[V_{t-\Delta t}(W', Y')\right] \right\},
\]</span> subject to the law of motion for wealth, <span class="math display">\[
  W' = R_{p,t+\Delta t}\,\bigl(W + (Y - c)\,\Delta t\bigr),
  \qquad
  R_{p,t+\Delta t} = (1-\alpha)\,R_f + \alpha\,R_{r,t+\Delta t},
\]</span> and a borrowing limit <span class="math inline">\(W \geq \underline{W}\)</span>, given a transition matrix <span class="math inline">\(\Pr(Y' = Y_j \mid Y = Y_i) = P_{ij}\)</span>.</p>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Note</strong></p>
</div>
<div class="callout-content">
<p>When deriving the continuous-time limit, it is essential to distinguish between <em>flow</em> and <em>stock</em> variables. The cash-on-hand variable, <span class="math display">\[
    M = W + Y\,\Delta t,
  \]</span> combines a stock (wealth) with a flow (labor income). As <span class="math inline">\(\Delta t \to 0\)</span>, this distinction vanishes, and <span class="math inline">\(M\)</span> and <span class="math inline">\(W\)</span> coincide in the limit.</p>
</div>
</div>
</div>
</div>
</section>
<section id="state-dynamics-in-continuous-time" class="slide level2 compact-slide">
<h2>State Dynamics in Continuous Time</h2>
<p><span class="text-blue"><strong>Wealth dynamics.</strong></span></p>
<ul>
<li>The discrete-time wealth process can be expressed as <span class="math display">\[
W_{t+\Delta t} - W_t = [(1-\alpha_t) r W_t + \alpha_t \mu_r W_t + Y_t - c_t]\Delta t + \alpha_t \sigma_r W_t \sqrt{\Delta t}\,\varepsilon_{r,t+\Delta t} + o(\Delta t),
\]</span></li>
</ul>
<p>Taking the limit as <span class="math inline">\(\Delta t \to 0\)</span>, we obtain the continuous-time wealth dynamics: <span class="math display">\[
  dW_t = [(1-\alpha_t) r W_t + \alpha_t \mu_r W_t + Y_t - c_t] dt + \alpha_t \sigma_r W_t\, dB_t,
\]</span> where <span class="math inline">\(B_t\)</span> is a standard Brownian motion.</p>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<p><span class="text-green"><strong>Labor income dynamics.</strong></span></p>
<ul>
<li>The expected change in income over a small interval <span class="math inline">\(\Delta t\)</span> is <span class="math display">\[
\mathbb{E}\left[Y_{t+\Delta t} - Y_t \mid Y_t = Y_i\right] = \sum_{j \neq i} \lambda_{ij} (Y_j - Y_i)\,\Delta t.
\]</span> In continuous time, this implies the following jump process for income: <span class="math display">\[
dY_t = \sum_{j} (Y_j - Y_i)\, dN_{ij,t}, \qquad \mathbb{E}[dN_{ij,t}] = \lambda_{ij}\,dt,
\]</span></li>
</ul>
</div>
</section>
<section id="the-hamilton-jacobi-bellman-equation" class="slide level2 compact-slide">
<h2>The Hamilton-Jacobi-Bellman Equation</h2>
<p>We now derive the continuous-time version of the Bellman equation: <span class="math display">\[
  0
  = \max_{c, \alpha}
    \Big\{
      u(c)
      + \frac{\mathbb{E}\!\left[V_{t-\Delta t}(W',Y') - V_t(W,Y)\,\middle|\,W,Y\right]}{\Delta t}
      - \rho\,V_t(W,Y)
    \Big\}
    + O(\Delta t).
\]</span> subject to the wealth dynamics and labor income dynamics.</p>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<p>Taking the limit as <span class="math inline">\(\Delta t \to 0\)</span>, we obtain the continuous-time Bellman equation: <span class="math display">\[
  \rho V_t(W,Y)\,dt
  = \max_{c, \alpha}
    \Big\{
      u(c)\,dt
      + \color{#d55e00}{\underbrace{\mathbb{E}\!\left[dV_t(W,Y)\right]}_{\text{drift term}}}
    \Big\}.
\]</span></p>
</div>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<p>Applying It√¥‚Äôs lemma to <span class="math inline">\(V_t(W,Y)\)</span>, we obtain the <span class="text-blue"><strong>Hamilton-Jacobi-Bellman (HJB)</strong></span> equation:</p>
<p><span class="math display">\[
\rho V_t(W,Y_i)
  = \max_{c,\alpha}
    \Big\{
      u(c)
      - \frac{\partial V_t}{\partial t}
      + \mathcal{D}V_t(W,Y_i)
      + \sum_{j \neq i} \lambda_{ij}\big[V_t(W,Y_j) - V_t(W,Y_i)\big]
    \Big\},
\]</span> where <span class="math inline">\(\mathcal{D}\)</span> is the Dynkin operator: <span class="math display">\[
  \mathcal{D}V_t(W,Y)
  = V_W\,[r W + \alpha (\mu_r - r) W + Y - c_t]
    + \tfrac{1}{2} V_{WW}\,(\alpha \sigma_r W)^2.
\]</span></p>
</div>
</section></section>
<section>
<section id="ii.-finite-differences-blackscholesmerton" class="title-slide slide level1 center">
<h1>II. Finite Differences: Black‚ÄìScholes‚ÄìMerton</h1>

</section>
<section id="a-blackscholesmerton-example" class="slide level2 compact-slide">
<h2>A Black‚ÄìScholes‚ÄìMerton Example</h2>
<p>We now show how to solve the HJB equation numerically using finite differences.</p>
<ul>
<li>As a warm-up exercise, we consider an option pricing problem in the <em>Black‚ÄìScholes‚ÄìMerton framework</em>.</li>
<li>This will provide a simpler setting where we can illustrate the main idea of the finite-difference method.</li>
</ul>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<p><span class="text-blue"><strong>Asset dynamics:</strong></span></p>
<ul>
<li>The risk-free rate is constant and equal to <span class="math inline">\(r\)</span>,</li>
<li>The stock price follows a geometric Brownian motion: <span class="math display">\[
dS_t = \mu_S S_t\,dt + \sigma_S S_t\,dB_t,
\]</span> where <span class="math inline">\(B_t\)</span> is a standard Brownian motion.</li>
</ul>
<div style="margin-top: 1.5em;">

</div>
</div>
<div class="fragment">
<p><span class="text-orange"><strong>No arbitrage:</strong></span></p>
<ul>
<li><p>We are interested in pricing the option using the <em>principle of no-arbitrage</em>.</p></li>
<li><p>The absence of arbitrage opportunities implies the existence of a <em>stochastic discount factor</em> <span class="math inline">\(\pi_t\)</span>: <span class="math display">\[
d\pi_t = -r\,\pi_t\,dt - \eta\,\pi_t\,dB_t,
\]</span> where <span class="math inline">\(\eta \equiv \frac{\mu_S - r}{\sigma_S}\)</span> is the market price of risk.</p></li>
</ul>
</div>
</section>
<section id="the-blackscholesmerton-pde" class="slide level2 compact-slide">
<h2>The Black‚ÄìScholes‚ÄìMerton PDE</h2>
<p>The value of a call option is given by <span class="math display">\[
  V_T(S) = \mathbb{E}_0\!\left[ \frac{\pi_T}{\pi_0}\,\max(S_T - K, 0) \,\middle|\, S_0 = S \right].
\]</span> with terminal payoff <span class="math inline">\(V_T(S) = \max(S - K, 0)\)</span>.</p>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<p>The HJB equation for this problem at time <span class="math inline">\(t \geq 0\)</span> is <span class="math display">\[
  0 = \mathbb{E}_t\!\left[\, d \bigl(\pi_t\,V_{T-t}(S_t)\bigr) \right].
\]</span></p>
<p>Applying It√¥‚Äôs lemma to <span class="math inline">\(\pi_t V_{T-t}(S_t)\)</span>, we obtain the <span class="text-blue"><strong>Black‚ÄìScholes‚ÄìMerton PDE</strong></span>: <span class="math display">\[
  -r\,V_T(S)
  - \frac{\partial V_T(S)}{\partial T}
  + r\,S\,\frac{\partial V_T(S)}{\partial S}
  + \tfrac{1}{2}\sigma_S^2 S^2\,\frac{\partial^2 V_T(S)}{\partial S^2} = 0,
\]</span> with terminal condition <span class="math inline">\(V_0(S) = \max(S - K, 0)\)</span>.</p>
</div>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<div class="callout callout-tip callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Tip</strong></p>
</div>
<div class="callout-content">
<p>It is convenient to express the PDE in terms of the log stock price <span class="math inline">\(s \equiv \log S\)</span>: <span class="math display">\[
  -r\,v_T(s)
  - \frac{\partial v_T(s)}{\partial T}
  + \overline{r}\,\frac{\partial v_T(s)}{\partial s}
  + \frac{1}{2}\sigma_S^2\,\frac{\partial^2 v_T(s)}{\partial s^2} = 0,
\]</span> with terminal condition <span class="math inline">\(v_0(s) = \max(e^s - K, 0)\)</span>, where <span class="math inline">\(\overline{r} \equiv r - \tfrac{1}{2}\sigma_S^2\)</span> is the risk-adjusted drift.</p>
</div>
</div>
</div>
</div>
</section>
<section id="finite-difference-approximations" class="slide level2 compact-slide">
<h2>Finite-difference approximations</h2>
<p>We can solve the PDE by discretizing both time and space (<span class="math inline">\(t\)</span> and <span class="math inline">\(s\)</span>).</p>
<ul>
<li>Let <span class="math inline">\(t \in \{t_1, t_2, \ldots, t_M\}\)</span> be the time on a uniform grid.</li>
<li>Let <span class="math inline">\(s \in \{s_1, s_2, \ldots, s_N\}\)</span> be the log stock price on a uniform grid.</li>
</ul>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<p>We can approximate the <em>spatial derivatives</em> in different ways:</p>
<div class="columns">
<div class="column" style="width:33%;">
<p><strong>Forward difference:</strong> <span class="math display">\[
  \frac{\partial v_{t_n}(s_i)}{\partial s} = \frac{v_{i+1}^n - v_i^n}{\Delta s},
\]</span></p>
</div><div class="column" style="width:33%;">
<p><strong>Backward difference:</strong> <span class="math display">\[
  \frac{\partial v_{t_n}(s_i)}{\partial s} = \frac{v_i^n - v_{i-1}^n}{\Delta s},
\]</span></p>
</div><div class="column" style="width:33%;">
<p><strong>Centered difference:</strong> <span class="math display">\[
  \frac{\partial v_{t_n}(s_i)}{\partial s} = \frac{v_{i+1}^n - v_{i-1}^n}{2\Delta s}.
\]</span></p>
</div></div>
</div>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<p>The <em>second spatial derivative</em> is approximated by a centered difference: <span class="math display">\[
  \frac{\partial^2 v_{t_n}(s_i)}{\partial s^2} = \frac{v_{i+1}^n - 2v_i^n + v_{i-1}^n}{\Delta s^2}.
\]</span></p>
</div>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<p>The <em>time derivative</em> is approximated by a forward Euler step: <span class="math display">\[
  \frac{\partial v_{t_n}(s_i)}{\partial T} = \frac{v_i^{n+1} - v_i^n}{\Delta t}.
\]</span></p>
</div>
</section>
<section id="explicit-scheme" class="slide level2 compact-slide">
<h2>Explicit scheme</h2>
<p>We fix a forward difference in time and consider two versions for the spatial derivative:</p>
<div class="columns">
<div class="column" style="width:50%;">
<p>The <span class="text-orange"><strong>forward-difference</strong></span> version is <span class="math display">\[
  r\,v_i^n
  = -\frac{v_i^{n+1} - v_i^n}{\Delta t}
    + \overline{r}\color{#d55e00}{\,\frac{v_{i+1}^n - v_i^n}{\Delta s}}
    + \frac{\sigma_S^2}{2}\,\frac{v_{i+1}^n - 2v_i^n + v_{i-1}^n}{\Delta s^2},
\]</span></p>
</div><div class="column" style="width:50%;">
<p>The <span class="text-green"><strong>backward-difference</strong></span> version is <span class="math display">\[
  r\,v_i^n
  = -\frac{v_i^{n+1} - v_i^n}{\Delta t}
    + \overline{r}\color{#009e73}{\,\frac{v_i^n - v_{i-1}^n}{\Delta s}}
    + \frac{\sigma_S^2}{2}\,\frac{v_{i+1}^n - 2v_i^n + v_{i-1}^n}{\Delta s^2}.
\]</span></p>
</div></div>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<p>Rearranging either form gives a common update rule: <span class="math display">\[
  v_i^{n+1}
  = -r\,\Delta t\,v_i^n
    + p_u\,v_{i+1}^n
    + p_s\,v_i^n
    + p_d\,v_{i-1}^n, \qquad i=2, \ldots, N-1,
\]</span> where, letting <span class="math inline">\(\mathbf{1}_{\text{F}}\)</span> and <span class="math inline">\(\mathbf{1}_{\text{B}}\)</span> denote the forward and backward difference indicators,</p>
<p><span class="math display">\[
p_u = \frac{\overline{r}\,\Delta t}{\Delta s}\,\mathbf{1}_{\text{F}}
       + \frac{\sigma_S^2\,\Delta t}{2\Delta s^2}, \qquad \qquad
       p_s = 1
       - \frac{\overline{r}\,\Delta t}{\Delta s}\,(\mathbf{1}_{\text{F}} - \mathbf{1}_{\text{B}})
       - \frac{\sigma_S^2\,\Delta t}{\Delta s^2}, \qquad \qquad
       p_d = -\frac{\overline{r}\,\Delta t}{\Delta s}\,\mathbf{1}_{\text{B}}
       + \frac{\sigma_S^2\,\Delta t}{2\Delta s^2}.
\]</span></p>
</div>
<div class="fragment">
<div style="margin-top: 0.75em;">

</div>
<div title="Boundary conditions">
<div class="callout callout-important callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Boundary conditions</strong></p>
</div>
<div class="callout-content">
<p>We handle boundaries using <span class="text-blue"><strong>ghost nodes</strong></span>, i.e., values outside the grid.</p>
<div class="columns">
<div class="column" style="width:50%;">
<p><strong>Right boundary.</strong> Option is deep in the money, so <span class="math inline">\(\frac{\partial v_{t_n}(s_N)}{\partial s} = e^{s_N}\)</span>: <span class="math display">\[
  v_{N+1}^n = v_N^n + e^{s_N}\,\Delta s.
\]</span></p>
</div><div class="column" style="width:50%;">
<p><strong>Left boundary.</strong> Option is far out of the money, so <span class="math inline">\(\frac{\partial v_{t_n}(s_1)}{\partial s} = 0\)</span>: <span class="math display">\[
  v_0^n = v_1^n.
\]</span></p>
</div></div>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="matrix-representation" class="slide level2 compact-slide">
<h2>Matrix representation</h2>
<p>Define <span class="math inline">\(\mathbf{v}^n = [v_1^n, v_2^n, \ldots, v_N^n]^\top\)</span> and the tridiagonal matrix of coefficients: <span class="math display">\[
  \mathbf{P}
  = \begin{pmatrix}
      p_s + p_d  &amp; p_u &amp; 0 &amp; \ldots &amp; 0 \\
      p_d &amp; p_s  &amp; p_u &amp; \ldots &amp; 0 \\
      \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
      0 &amp; \ldots &amp; p_d &amp; p_s  &amp; p_u \\
      0 &amp; \ldots &amp; 0 &amp; p_d &amp; p_s + p_u
    \end{pmatrix}.
\]</span> Then the law of motion for <span class="math inline">\(\mathbf{v}^n\)</span> is <span class="math display">\[
  \mathbf{v}^{n+1}
  = \mathbf{P}^r\,\mathbf{v}^n + \mathbf{b},
  \qquad
  \mathbf{P}^r \equiv \mathbf{P} - r\,\Delta t\,\mathbf{I}_N,
\]</span> with initial condition <span class="math inline">\(\mathbf{v}^0 = [v_0(s_1), v_0(s_2), \ldots, v_0(s_N)]^\top\)</span>, and adjustment vector <span class="math inline">\(\mathbf{b} = [0, \ldots, 0,\, p_u\,e^{s_N}\,\Delta s]^\top\)</span>.</p>
</section>
<section id="julia-implementation" class="slide level2 compact-slide">
<h2>Julia implementation</h2>
<p>We start by defining the model structure for the Black‚ÄìScholes‚ÄìMerton problem.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="black_scholes_struct"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="black_scholes_struct-1"><a href="#black_scholes_struct-1"></a><span class="pp">@kwdef</span> <span class="kw">struct</span> BlackScholesModel</span>
<span id="black_scholes_struct-2"><a href="#black_scholes_struct-2"></a>    œÉS<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">0.20</span></span>
<span id="black_scholes_struct-3"><a href="#black_scholes_struct-3"></a>    r<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">0.05</span></span>
<span id="black_scholes_struct-4"><a href="#black_scholes_struct-4"></a>    K<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">1.0</span></span>
<span id="black_scholes_struct-5"><a href="#black_scholes_struct-5"></a>    T<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">1.0</span></span>
<span id="black_scholes_struct-6"><a href="#black_scholes_struct-6"></a>    Ns<span class="op">::</span><span class="dt">Int64 </span><span class="op">=</span> <span class="fl">150</span></span>
<span id="black_scholes_struct-7"><a href="#black_scholes_struct-7"></a>    Nt<span class="op">::</span><span class="dt">Int64 </span><span class="op">=</span> <span class="fl">300</span></span>
<span id="black_scholes_struct-8"><a href="#black_scholes_struct-8"></a>    sgrid<span class="op">::</span><span class="dt">LinRange{Float64} </span><span class="op">=</span> <span class="fu">range</span>(<span class="op">-</span><span class="fl">1.5</span>, <span class="fl">1.5</span>, length<span class="op">=</span>Ns)</span>
<span id="black_scholes_struct-9"><a href="#black_scholes_struct-9"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<p>We then implement the finite-difference scheme.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="fd_scheme" data-code-line-numbers="1-21|2|3-4|5-8|9-11|12-14|15-19|1-21"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="fd_scheme-1"><a href="#fd_scheme-1"></a><span class="kw">function</span> <span class="fu">fd_scheme</span>(m<span class="op">::</span><span class="dt">BlackScholesModel</span>; forward<span class="op">::</span><span class="dt">Bool </span><span class="op">=</span> <span class="cn">true</span>)</span>
<span id="fd_scheme-2"><a href="#fd_scheme-2"></a>    (; œÉS, r, K, T, Ns, Nt, sgrid) <span class="op">=</span> m <span class="co"># unpack model parameters</span></span>
<span id="fd_scheme-3"><a href="#fd_scheme-3"></a>    Œîs, Œît <span class="op">=</span> sgrid[<span class="fl">2</span>] <span class="op">-</span> sgrid[<span class="fl">1</span>], T <span class="op">/</span> (Nt <span class="op">-</span> <span class="fl">1</span>) <span class="co"># spatial/time steps</span></span>
<span id="fd_scheme-4"><a href="#fd_scheme-4"></a>    rÃÖ <span class="op">=</span> r <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> œÉS<span class="op">^</span><span class="fl">2</span> <span class="co"># risk-adjusted drift</span></span>
<span id="fd_scheme-5"><a href="#fd_scheme-5"></a>    <span class="co"># Coefficients for the tridiagonal matrix</span></span>
<span id="fd_scheme-6"><a href="#fd_scheme-6"></a>    pu <span class="op">=</span> rÃÖ <span class="op">*</span> Œît <span class="op">/</span> Œîs <span class="op">*</span> forward <span class="op">+</span> œÉS<span class="op">^</span><span class="fl">2</span> <span class="op">*</span> Œît <span class="op">/</span> (<span class="fl">2</span> <span class="op">*</span> Œîs<span class="op">^</span><span class="fl">2</span>)</span>
<span id="fd_scheme-7"><a href="#fd_scheme-7"></a>    ps <span class="op">=</span> <span class="fl">1</span> <span class="op">-</span> rÃÖ <span class="op">*</span> Œît <span class="op">/</span> Œîs <span class="op">*</span> (<span class="fl">2</span><span class="op">*</span>forward<span class="op">-</span><span class="fl">1</span>) <span class="op">-</span> œÉS<span class="op">^</span><span class="fl">2</span> <span class="op">*</span> Œît <span class="op">/</span> (Œîs<span class="op">^</span><span class="fl">2</span>)</span>
<span id="fd_scheme-8"><a href="#fd_scheme-8"></a>    pd <span class="op">=</span> <span class="op">-</span>rÃÖ <span class="op">*</span> Œît <span class="op">/</span> Œîs <span class="op">*</span> (<span class="fl">1</span><span class="op">-</span>forward) <span class="op">+</span> œÉS<span class="op">^</span><span class="fl">2</span> <span class="op">*</span> Œît <span class="op">/</span> (<span class="fl">2</span> <span class="op">*</span> Œîs<span class="op">^</span><span class="fl">2</span>)</span>
<span id="fd_scheme-9"><a href="#fd_scheme-9"></a>    <span class="cn">e</span>  <span class="op">=</span> <span class="fu">zeros</span>(Ns)</span>
<span id="fd_scheme-10"><a href="#fd_scheme-10"></a>    <span class="cn">e</span>[<span class="fl">1</span>], <span class="cn">e</span>[<span class="kw">end</span>] <span class="op">=</span> pd, pu <span class="co"># set boundary conditions</span></span>
<span id="fd_scheme-11"><a href="#fd_scheme-11"></a>    P <span class="op">=</span> <span class="fu">Tridiagonal</span>(<span class="fu">pd*ones</span>(Ns<span class="op">-</span><span class="fl">1</span>), <span class="fu">ps*ones</span>(Ns)<span class="op">+</span><span class="cn">e</span>, <span class="fu">pu*ones</span>(Ns<span class="op">-</span><span class="fl">1</span>))</span>
<span id="fd_scheme-12"><a href="#fd_scheme-12"></a>    <span class="co"># Boundary conditions</span></span>
<span id="fd_scheme-13"><a href="#fd_scheme-13"></a>    b <span class="op">=</span> <span class="fu">zeros</span>(Ns)</span>
<span id="fd_scheme-14"><a href="#fd_scheme-14"></a>    b[<span class="kw">end</span>] <span class="op">=</span> pu <span class="op">*</span> <span class="fu">exp</span>(sgrid[<span class="kw">end</span>]) <span class="op">*</span> Œîs</span>
<span id="fd_scheme-15"><a href="#fd_scheme-15"></a>    <span class="co"># Initial condition</span></span>
<span id="fd_scheme-16"><a href="#fd_scheme-16"></a>    v <span class="op">=</span> @. <span class="fu">max</span>(<span class="fl">0.0</span>, <span class="fu">exp</span>(sgrid) <span class="op">-</span> K) <span class="co"># terminal condition</span></span>
<span id="fd_scheme-17"><a href="#fd_scheme-17"></a>    <span class="cf">for</span> n <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span>Nt</span>
<span id="fd_scheme-18"><a href="#fd_scheme-18"></a>        v <span class="op">=</span> (P <span class="op">-</span> r <span class="op">*</span> Œît <span class="op">*</span> I) <span class="op">*</span> v <span class="op">+</span> b <span class="co"># update rule</span></span>
<span id="fd_scheme-19"><a href="#fd_scheme-19"></a>    <span class="cf">end</span></span>
<span id="fd_scheme-20"><a href="#fd_scheme-20"></a>    <span class="cf">return</span> (; P, b, v)</span>
<span id="fd_scheme-21"><a href="#fd_scheme-21"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="forward-vs.-backward-differences" class="slide level2 compact-slide">
<h2>Forward vs.&nbsp;Backward Differences</h2>
<div class="columns">
<div class="column" style="width:50%;">
<p><span class="text-orange"><strong>Forward difference</strong></span></p>
<p><img data-src="Figures/vf1.png" style="width:70.0%"></p>
<p><img data-src="Figures/vf2.png" style="width:70.0%"></p>
</div><div class="column" style="width:50%;">
<p><span class="text-green"><strong>Backward difference</strong></span></p>
<p><img data-src="Figures/vb1.png" style="width:70.0%"></p>
<p><img data-src="Figures/vb2.png" style="width:70.0%"></p>
</div></div>
<p>Top row: positive drift. Bottom row: negative drift.</p>
</section>
<section id="markov-chain-approximation-mca" class="slide level2 compact-slide">
<h2>Markov Chain Approximation (MCA)</h2>
<p>The plots above motivate the use of an <span class="text-blue"><strong>upwind scheme</strong></span>:</p>
<ul>
<li>Use a <span class="text-orange"><strong>forward difference</strong></span> when the drift is positive.</li>
<li>Use a <span class="text-green"><strong>backward difference</strong></span> when the drift is negative.</li>
</ul>
<p>This choice suppresses numerical oscillations and improves stability of the explicit scheme.</p>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<p>But why does upwinding work?</p>
<ul>
<li>A useful perspective comes from the <span class="text-blue"><strong>Markov Chain Approximation (MCA)</strong></span> of <span class="citation" data-cites="KushnerDupuis2001">Kushner and Dupuis (<a href="#/references" role="doc-biblioref" onclick="">2001</a>)</span>.</li>
</ul>
<p>The MCA approach starts from the discretized Bellman equation <span class="math display">\[
  v_T(s) = (1 - r\,\Delta t)\,\mathbb{E}\!\left[\,v_{T-\Delta t}(s') \,\middle|\, s\,\right],
\]</span> under the risk‚Äìneutral log‚Äìprice dynamics with drift <span class="math inline">\(\overline r\)</span> and variance <span class="math inline">\(\sigma_S^2\)</span>: <span class="math display">\[
  \mathbb{E}[\,s' - s \mid s\,] = \overline r\,\Delta t,
  \qquad
  \operatorname{Var}[\,s' \mid s\,] = \sigma_S^2\,\Delta t.
\]</span></p>
</div>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<p><strong>Key idea:</strong> Let‚Äôs assume <span class="math inline">\(s\)</span> follows a Markov chain on the grid <span class="math inline">\(\{s_i\}_{i=1}^N\)</span></p>
<ul>
<li>Starting at <span class="math inline">\(s_i\)</span>, the log price can move only to <span class="math inline">\(s_{i-1}\)</span>, <span class="math inline">\(s_i\)</span>, or <span class="math inline">\(s_{i+1}\)</span></li>
<li>The transition probabilities <span class="math inline">\((p_d, p_s, p_u)\)</span> are chosen to match the local mean and variance.</li>
</ul>
</div>
</section>
<section id="the-cfl-condition" class="slide level2 compact-slide">
<h2>The CFL Condition</h2>
<p>A locally consistent choice for the transition probabilities is <span class="math display">\[
  p_u = \frac{\overline r\,\Delta t}{\Delta s}\,\mathbf{1}_{\{\overline r \ge 0\}} + \frac{\sigma_S^2\,\Delta t}{2\Delta s^2},\quad
  p_s = 1 - \frac{|\overline r|\,\Delta t}{\Delta s} - \frac{\sigma_S^2\,\Delta t}{\Delta s^2},\quad
  p_d = -\,\frac{\overline r\,\Delta t}{\Delta s}\,\mathbf{1}_{\{\overline r &lt; 0\}} + \frac{\sigma_S^2\,\Delta t}{2\Delta s^2}.
\]</span></p>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<p>We need to ensure that <span class="math inline">\((p_d, p_s, p_u)\)</span> are non-negative and sum to 1.</p>
<ul>
<li>These satisfy <span class="math inline">\(p_u + p_s + p_d = 1\)</span> by construction.</li>
<li>Upwinding ensures <span class="math inline">\(p_u \ge 0\)</span> and <span class="math inline">\(p_d \ge 0\)</span></li>
</ul>
<div style="margin-top: 1.5em;">

</div>
</div>
<div class="fragment">
<p>To ensure the nonnegativity of <span class="math inline">\(p_s\)</span>, we need to impose the <span class="text-orange"><strong>Courant‚ÄìFriedrichs‚ÄìLewy (CFL)</strong></span> condition: <span class="math display">\[
  1 - \frac{|\overline r|\,\Delta t}{\Delta s} - \frac{\sigma_S^2\,\Delta t}{\Delta s^2} \ge 0
  \quad\Longleftrightarrow\quad
  \Delta t \le \frac{\Delta s^2}{\,|\overline r|\,\Delta s + \sigma_S^2\,}.
\]</span></p>
<div class="callout callout-important callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Important</strong></p>
</div>
<div class="callout-content">
<p>The CFL condition is crucial to ensure that the transition probabilities are non-negative.</p>
<ul>
<li>Violating it produces instability and spurious oscillations in the numerical solution.</li>
</ul>
</div>
</div>
</div>
</div>
</section>
<section id="discretization-error" class="slide level2 compact-slide">
<h2>Discretization Error</h2>
<p>A key aspect of the CFL condition for the explicit scheme is a restriction on <span class="math inline">\(\Delta t\)</span></p>
<ul>
<li>The time step <span class="math inline">\(\Delta t\)</span> must shrink as the spatial step <span class="math inline">\(\Delta s\)</span> shrinks to maintain stability.</li>
<li>We can illustrate this with a heatmap of the discretization error.</li>
</ul>

<img data-src="Figures/error_heatmap.png" style="width:100.0%" class="r-stretch"></section>
<section id="the-barles-souganidis-conditions" class="slide level2 compact-slide">
<h2>The Barles-Souganidis Conditions</h2>
<p>The analysis above provided a probabilistic intuition for the stability of the finite-difference scheme.</p>
<ul>
<li>A complementary and more general approach is given by the <span class="citation" data-cites="BarlesSouganidis1991">Barles and Souganidis (<a href="#/references" role="doc-biblioref" onclick="">1991</a>)</span> theorem.</li>
<li>The theorem provides sufficient conditions for the convergence of the finite-difference schemes</li>
</ul>
<div class="fragment">
<p><strong>Main result.</strong> Consider a numerical scheme of the general form <span class="math display">\[
  F^h(x, V(x), V(\cdot)) = 0,
\]</span> where <span class="math inline">\(h\)</span> collects the discretization parameters (e.g., <span class="math inline">\(\Delta t\)</span>, <span class="math inline">\(\Delta s\)</span>), and <span class="math inline">\(V\)</span> is the numerical approximation to the value function.</p>
<p><span class="citation" data-cites="BarlesSouganidis1991">Barles and Souganidis (<a href="#/references" role="doc-biblioref" onclick="">1991</a>)</span> provide conditions for the convergence to the <em>viscosity solution</em> of the HJB equation.</p>
<div title="Barles--Souganidis theorem">
<div class="callout callout-important callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Barles‚ÄìSouganidis theorem</strong></p>
</div>
<div class="callout-content">
<p>Suppose that the continuous-time problem admits a unique bounded viscosity solution. If a numerical scheme is:</p>
<ol type="1">
<li><strong>Monotone:</strong> The numerical operator <span class="math inline">\(F^h\)</span> is non-decreasing in <span class="math inline">\(V\)</span>.</li>
<li><strong>Stable:</strong> The sequence of numerical approximations <span class="math inline">\(V^h\)</span> remains uniformly bounded.</li>
<li><strong>Consistent:</strong> As <span class="math inline">\(h \to 0\)</span>, the discrete operator <span class="math inline">\(F^h\)</span> converges to the continuous operator <span class="math inline">\(F\)</span> defining the PDE.</li>
</ol>
<p>Then the scheme converges locally uniformly to the viscosity solution of the HJB equation.</p>
</div>
</div>
</div>
</div>
</div>
<div class="fragment">
<div class="callout callout-tip callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Tip</strong></p>
</div>
<div class="callout-content">
<p>A <em>viscosity solution</em> is a generalized notion of solution to nonlinear PDEs like the HJB equation, which applies to problems where the value function may exhibit kinks or corners, as is typical in dynamic optimization problems with borrowing constraints or nonconvexities.</p>
</div>
</div>
</div>
</div>
</section>
<section id="connection-to-the-explicit-upwind-scheme" class="slide level2 compact-slide">
<h2>Connection to the explicit upwind scheme</h2>
<p>Consider our explicit upwind scheme: <span class="math display">\[
  v_i^{n+1} = p_u^r\,v_{i+1}^n + p_s^r\,v_i^n + p_d^r\,v_{i-1}^n + b_i^n,
\]</span> with coefficients <span class="math inline">\(p_u^r = p_u, p_s^r = p_s-r\,\Delta t, p_d^r = p_d\)</span>.</p>
<p>The scheme is therefore:</p>
<ul>
<li><strong>Monotone:</strong> if <span class="math inline">\(p_u^r, p_s^r, p_d^r \ge 0\)</span> ‚Äî that is, when upwinding and the CFL condition hold.</li>
<li><strong>Stable:</strong> if <span class="math inline">\(\|v^n\|\)</span> remains bounded, which again follows from <span class="math inline">\(p_u^r + p_s^r + p_d^r = 1-r\,\Delta t \leq 1\)</span> and nonnegativity.</li>
<li><strong>Consistent:</strong> because the finite-difference approximations converge to their continuous counterparts as <span class="math inline">\(\Delta s, \Delta t \to 0\)</span>.</li>
</ul>
</section>
<section id="implicit-schemes" class="slide level2 compact-slide">
<h2>Implicit schemes</h2>
<p>We will use the Barles‚ÄìSouganidis theorem to analyze the stability of implicit schemes.</p>
<ul>
<li>The implicit version of the discretization of the Black‚ÄìScholes‚ÄìMerton PDE is <span class="math display">\[
r\,v_i^{n+1}
= -\frac{v_i^{n+1} - v_i^n}{\Delta t}
  + \overline{r} \left[\mathbf{1}_{\{\overline{r} \ge 0\}} \,\frac{v_{i+1}^{n+1} - v_i^{n+1}}{\Delta s}
  + \mathbf{1}_{\{\overline{r} &lt; 0\}} \,\frac{v_{i}^{n+1} - v_{i-1}^{n+1}}{\Delta s}\right]
  + \frac{\sigma_S^2}{2}\,\frac{v_{i+1}^{n+1} - 2v_i^{n+1} + v_{i-1}^{n+1}}{\Delta s^2},
\]</span></li>
</ul>
<div class="fragment">
<div style="margin-top: 0.5em;">

</div>
<p>We can rewrite the equation above as <span class="math display">\[
  v_i^{n+1} = v_i^n + p_u^r\,v_{i+1}^{n+1} - \delta^r\,v_i^{n+1} + p_d^r\,v_{i-1}^{n+1},
\]</span> where <span class="math inline">\(\delta^r \equiv p_u^r+p_d^r+r\,\Delta t\)</span>.</p>
</div>
<div class="fragment">
<div style="margin-top: 0.5em;">

</div>
<p>In matrix form, we have <span class="math display">\[
   \mathbf{A} \mathbf{v}^{n+1} = \mathbf{v}^n+ \mathbf{b},
\]</span> where <span class="math inline">\(\mathbf{A}\)</span> is a tridiagonal matrix of coefficients: <span class="math display">\[
  \mathbf{A} = \begin{pmatrix}
    1+\delta^r - p_d^r &amp;-p_u^r &amp; 0 &amp; \ldots &amp; 0 \\
    -p_d^r &amp; 1+\delta^r &amp; -p_u^r &amp; \ldots &amp; 0 \\
    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
    0 &amp; \ldots &amp; -p_d^r &amp; 1+\delta^r &amp; -p_u^r \\
    0 &amp; \ldots &amp; 0 &amp; -p_d^r &amp; 1+\delta^r -p_u^r
  \end{pmatrix}.
\]</span></p>
</div>
</section>
<section id="checking-the-barles-souganidis-conditions" class="slide level2 compact-slide">
<h2>Checking the Barles-Souganidis conditions</h2>
<p>We need to check that the scheme is monotone, stable, and consistent.</p>
<ul>
<li>The discretization ensures <em>consistency</em> and <span class="math inline">\(r&gt;0\)</span> ensures <em>stability</em>.</li>
<li>The main condition we need to check is <span class="text-orange"><strong>monotonicity</strong></span>.</li>
<li>Monotonicity requires that, if <span class="math inline">\(\mathbf{v}^n\)</span> and <span class="math inline">\(\mathbf{u}^{n}\)</span> satisfy the recursion, and <span class="math inline">\(\mathbf{v}^n \ge \mathbf{u}^{n}\)</span>, then <span class="math inline">\(\mathbf{v}^{n+1} \ge \mathbf{u}^{n+1}\)</span>.</li>
</ul>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<p>This is equivalent to saying that <span class="math inline">\(\mathbf{A}\)</span> is a M-matrix.<a href="https://en.wikipedia.org/wiki/M-matrix" class="about-link">üåê</a></p>
<ul>
<li><p>Sufficient condition: off-diagonal elements are non-positive and the diagonal is strictly dominant: <span class="math inline">\(\mathbf{A}_{ii} &gt; \sum_{j \neq i} |\mathbf{A}_{ij}|\)</span>.</p></li>
<li><p>Upwinding ensures that the off-diagonal elements, <span class="math inline">\(p_u^r\)</span> and <span class="math inline">\(p_d^r\)</span>, are non-positive.</p></li>
</ul>
</div>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<p>Strict diagonal dominance requires: <span class="math display">\[
  1+\delta^r &gt; |p_d^r| + |p_u^r| \iff 1+r \Delta t &gt; 0,
\]</span> which holds for <em>any</em> <span class="math inline">\(\Delta t &gt; 0\)</span> provided <span class="math inline">\(r &gt; 0\)</span>.</p>
<div class="callout callout-important callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Important</strong></p>
</div>
<div class="callout-content">
<p>The condition above plays the same role as the CFL condition in ensuring monotonicity, but unlike in the explicit scheme, it imposes no restriction on <span class="math inline">\(\Delta t\)</span>. This property is often referred to as <span class="text-green"><strong>unconditional stability</strong></span>.</p>
</div>
</div>
</div>
</div>
</section>
<section id="julia-implementation-1" class="slide level2 compact-slide">
<h2>Julia implementation</h2>
<p>We can implement the implicit scheme as follows:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="fd_implicit" data-code-line-numbers="1-23|2|3-4|5-9|10-13|14-16|17-21"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="fd_implicit-1"><a href="#fd_implicit-1"></a><span class="kw">function</span> <span class="fu">fd_implicit</span>(m<span class="op">::</span><span class="dt">BlackScholesModel</span>)</span>
<span id="fd_implicit-2"><a href="#fd_implicit-2"></a>    (; œÉS, r, K, T, Ns, Nt, sgrid) <span class="op">=</span> m <span class="co"># unpack model parameters</span></span>
<span id="fd_implicit-3"><a href="#fd_implicit-3"></a>    Œîs, Œît <span class="op">=</span> sgrid[<span class="fl">2</span>] <span class="op">-</span> sgrid[<span class="fl">1</span>], T <span class="op">/</span> (Nt <span class="op">-</span> <span class="fl">1</span>) <span class="co"># spatial/time steps</span></span>
<span id="fd_implicit-4"><a href="#fd_implicit-4"></a>    rÃÖ <span class="op">=</span> r <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> œÉS<span class="op">^</span><span class="fl">2</span> <span class="co"># risk-adjusted drift</span></span>
<span id="fd_implicit-5"><a href="#fd_implicit-5"></a>    <span class="co"># Coefficients for the tridiagonal matrix</span></span>
<span id="fd_implicit-6"><a href="#fd_implicit-6"></a>    forward <span class="op">=</span> rÃÖ <span class="op">&gt;</span> <span class="fl">0</span> ? <span class="fl">1</span> <span class="op">:</span> <span class="fl">0</span></span>
<span id="fd_implicit-7"><a href="#fd_implicit-7"></a>    pu <span class="op">=</span> rÃÖ <span class="op">*</span> Œît <span class="op">/</span> Œîs <span class="op">*</span> forward <span class="op">+</span> œÉS<span class="op">^</span><span class="fl">2</span> <span class="op">*</span> Œît <span class="op">/</span> (<span class="fl">2</span> <span class="op">*</span> Œîs<span class="op">^</span><span class="fl">2</span>)</span>
<span id="fd_implicit-8"><a href="#fd_implicit-8"></a>    ps <span class="op">=</span> <span class="fl">1</span> <span class="op">-</span> rÃÖ <span class="op">*</span> Œît <span class="op">/</span> Œîs <span class="op">*</span> (<span class="fl">2</span><span class="op">*</span>forward<span class="op">-</span><span class="fl">1</span>) <span class="op">-</span> œÉS<span class="op">^</span><span class="fl">2</span> <span class="op">*</span> Œît <span class="op">/</span> (Œîs<span class="op">^</span><span class="fl">2</span>)</span>
<span id="fd_implicit-9"><a href="#fd_implicit-9"></a>    pd <span class="op">=</span> <span class="op">-</span>rÃÖ <span class="op">*</span> Œît <span class="op">/</span> Œîs <span class="op">*</span> (<span class="fl">1</span><span class="op">-</span>forward) <span class="op">+</span> œÉS<span class="op">^</span><span class="fl">2</span> <span class="op">*</span> Œît <span class="op">/</span> (<span class="fl">2</span> <span class="op">*</span> Œîs<span class="op">^</span><span class="fl">2</span>)</span>
<span id="fd_implicit-10"><a href="#fd_implicit-10"></a>    <span class="cn">e</span>  <span class="op">=</span> <span class="fu">zeros</span>(Ns)</span>
<span id="fd_implicit-11"><a href="#fd_implicit-11"></a>    <span class="cn">e</span>[<span class="fl">1</span>], <span class="cn">e</span>[<span class="kw">end</span>] <span class="op">=</span> pd, pu <span class="co"># set boundary conditions</span></span>
<span id="fd_implicit-12"><a href="#fd_implicit-12"></a>    P <span class="op">=</span> <span class="fu">Tridiagonal</span>(<span class="fu">pd*ones</span>(Ns<span class="op">-</span><span class="fl">1</span>), <span class="fu">ps*ones</span>(Ns)<span class="op">+</span><span class="cn">e</span>, <span class="fu">pu*ones</span>(Ns<span class="op">-</span><span class="fl">1</span>))</span>
<span id="fd_implicit-13"><a href="#fd_implicit-13"></a>    A <span class="op">=</span> (<span class="fl">2</span><span class="op">+</span>r <span class="op">*</span> Œît) <span class="op">*</span> I <span class="op">-</span> P </span>
<span id="fd_implicit-14"><a href="#fd_implicit-14"></a>    <span class="co"># Boundary conditions</span></span>
<span id="fd_implicit-15"><a href="#fd_implicit-15"></a>    b <span class="op">=</span> <span class="fu">zeros</span>(Ns)</span>
<span id="fd_implicit-16"><a href="#fd_implicit-16"></a>    b[<span class="kw">end</span>] <span class="op">=</span> pu <span class="op">*</span> <span class="fu">exp</span>(sgrid[<span class="kw">end</span>]) <span class="op">*</span> Œîs</span>
<span id="fd_implicit-17"><a href="#fd_implicit-17"></a>    <span class="co"># Initial condition</span></span>
<span id="fd_implicit-18"><a href="#fd_implicit-18"></a>    v <span class="op">=</span> @. <span class="fu">max</span>(<span class="fl">0.0</span>, <span class="fu">exp</span>(sgrid) <span class="op">-</span> K) <span class="co"># terminal condition</span></span>
<span id="fd_implicit-19"><a href="#fd_implicit-19"></a>    <span class="cf">for</span> n <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span>Nt</span>
<span id="fd_implicit-20"><a href="#fd_implicit-20"></a>        v <span class="op">=</span> A <span class="op">\</span> (v <span class="op">+</span> b) <span class="co"># update rule</span></span>
<span id="fd_implicit-21"><a href="#fd_implicit-21"></a>    <span class="cf">end</span></span>
<span id="fd_implicit-22"><a href="#fd_implicit-22"></a>    <span class="cf">return</span> (; P, b, v)</span>
<span id="fd_implicit-23"><a href="#fd_implicit-23"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="the-implicit-scheme-in-action" class="slide level2 compact-slide">
<h2>The Implicit Scheme in Action</h2>
<p>We can plot the solution of the Black‚ÄìScholes‚ÄìMerton PDE using the implicit scheme.</p>
<ul>
<li>The left panel compares the numerical solution with the exact Black‚ÄìScholes‚ÄìMerton formula.</li>
<li>The right panel shows the error heatmap.</li>
<li>Increasing the number of grid points in the spatial dimension reduces the error.</li>
</ul>
<div class="columns">
<div class="column" style="width:50%;">
<p><img data-src="Figures/vi.png" style="width:100.0%"></p>
</div><div class="column" style="width:50%;">
<p><img data-src="Figures/error_heatmap_implicit.png" style="width:100.0%"></p>
</div></div>
</section></section>
<section>
<section id="iii.-finite-differences-income-fluctuations-problem" class="title-slide slide level1 center">
<h1>III. Finite Differences: Income Fluctuations Problem</h1>

</section>
<section id="income-fluctuations-problem" class="slide level2 compact-slide">
<h2>Income Fluctuations Problem</h2>
<p>We now solve the income fluctuations problem using a finite-difference scheme.</p>
<ul>
<li>Relative to the option pricing problem, we must handle (i) the optimal consumption choice and (ii) the borrowing constraint.</li>
<li>Following <span class="citation" data-cites="achdou2022income">Achdou et al. (<a href="#/references" role="doc-biblioref" onclick="">2022</a>)</span>, we consider the case without portfolio choice and a two-state income process.</li>
</ul>
<div class="fragment">
<div style="margin-top: 1.0em;">

</div>
<p><span class="text-blue"><strong>HJB equation:</strong></span> <span class="math display">\[
  \rho\,V_{j,t}(W)
  \;=\;
  u \big(c_{j,t}(W)\big)
  \;-\; \frac{\partial V_{j,t}}{\partial t}(W)
  \;+\; \frac{\partial V_{j,t}}{\partial W}(W)\,\big[rW + Y_j - c_{j,t}(W)\big]
  \;+\; \lambda_j \big[V_{-j,t}(W)-V_{j,t}(W)\big],
\]</span> where <span class="math inline">\(c_{j,t}(W) = u'^{-1}\!\big(V_{j,t}'(W)\big)\)</span> and <span class="math inline">\(\lambda_j\in\{\lambda_1,\lambda_2\}\)</span> is the outgoing intensity from state <span class="math inline">\(j\)</span>.</p>
</div>
<div class="fragment">
<div style="margin-top: 1.0em;">

</div>
<p><span class="text-orange"><strong>Upwinding.</strong></span> Define forward and backward differences for the wealth derivative: <span class="math display">\[
  v_{i,j,F}^{\,n} \;=\; \frac{v_{i+1,j}^{\,n}-v_{i,j}^{\,n}}{\Delta W},
  \qquad
  v_{i,j,B}^{\,n} \;=\; \frac{v_{i,j}^{\,n}-v_{i-1,j}^{\,n}}{\Delta W}.
\]</span> The corresponding wealth drifts are <span class="math display">\[
  \mu_{i,j,F}^{\,n} \;=\; r W_i + Y_j - u'^{-1}\!\big(v_{i,j,F}^{\,n}\big),
  \qquad
  \mu_{i,j,B}^{\,n} \;=\; r W_i + Y_j - u'^{-1}\!\big(v_{i,j,B}^{\,n}\big).
\]</span></p>
</div>
<div class="fragment">
<div style="margin-top: 1.0em;">

</div>
<p>The upwinded derivative used in the drift: <span class="math display">\[
  v_{i,j,W}^{\,n}
  \;=\;
  v_{i,j,F}^{\,n}\,\mathbf{1}_{\{\mu_{i,j,F}^{\,n}&gt;0\}}
  \;+\;
  v_{i,j,B}^{\,n}\,\mathbf{1}_{\{\mu_{i,j,B}^{\,n}&lt;0\}}
  \;+\;
  \overline v_{i,j}\,\mathbf{1}_{\{\mu_{i,j,F}^{\,n}\le 0 \le \mu_{i,j,B}^{\,n}\}},
\]</span> where <span class="math inline">\(\overline v_{i,j} \equiv u'(rW_i+Y_j)\)</span>.</p>
</div>
</section>
<section id="semi-implicit-upwind-scheme" class="slide level2 compact-slide">
<h2>Semi-implicit upwind scheme</h2>
<p>Let <span class="math inline">\([x]^+=\max\{x,0\}\)</span> and <span class="math inline">\([x]^-=\min\{x,0\}\)</span>. The semi-implicit scheme is <span class="math display">\[
  \rho\,v_{i,j}^{\,n+1}
  \;=\;
  u_{i,j}^{\,n}
  \;-\; \frac{v_{i,j}^{\,n+1}-v_{i,j}^{\,n}}{\Delta t}
  \;+\; \frac{v_{i+1,j}^{\,n+1}-v_{i,j}^{\,n+1}}{\Delta W}\,[\mu_{i,j,F}^{\,n}]^{+}
  \;+\; \frac{v_{i,j}^{\,n+1}-v_{i-1,j}^{\,n+1}}{\Delta W}\,[\mu_{i,j,B}^{\,n}]^{-}
  \;+\; \lambda_j\!\left(v_{i,-j}^{\,n+1}-v_{i,j}^{\,n+1}\right).
\]</span> Rearranging, yields the linear system <span class="math display">\[
  -\ell_{i,j}^{\,n}\,v_{i-1,j}^{\,n+1}
  \;+\;
  s_{i,j}^{\,n}\,v_{i,j}^{\,n+1}
  \;-\;
  r_{i,j}^{\,n}\,v_{i+1,j}^{\,n+1}
  \;-\;
  \lambda_j\,v_{i,-j}^{\,n+1}
  \;=\;
  \frac{1}{\Delta t}\,v_{i,j}^{\,n} \;+\; u_{i,j}^{\,n},
  \label{eq:semi_implicit_linear}
\]</span> with nonnegative coefficients <span class="math display">\[
\begin{align}
  \ell_{i,j}^{\,n} &amp;\equiv -\frac{[\mu_{i,j,B}^{\,n}]^{-}}{\Delta W} \;\ge 0,\\
  r_{i,j}^{\,n}    &amp;\equiv \;\frac{[\mu_{i,j,F}^{\,n}]^{+}}{\Delta W} \;\ge 0,\\
  s_{i,j}^{\,n}    &amp;\equiv \frac{1}{\Delta t} \;+\; \ell_{i,j}^{\,n} \;+\; r_{i,j}^{\,n} \;+\; \rho+\lambda_j.
\end{align}
\]</span></p>
<div style="margin-top: 1.5em;">

</div>
<div class="fragment">
<div title="Boundary conditions">
<div class="callout callout-important callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Boundary conditions</strong></p>
</div>
<div class="callout-content">
<p>To impose the no-borrowing condition at the lower boundary <span class="math inline">\(W=\underline W\)</span>, and reflection at the upper boundary <span class="math inline">\(W=\overline W\)</span>, set <span class="math display">\[
  v_{1,j,B}^{\,n} \;=\; u'(rW_1+Y_j), \qquad \qquad v_{N,j,F}^{\,n} \;=\; u'(rW_N+Y_j).
\]</span> Hence, by construction, <span class="math inline">\(\ell_{1,j}^{\,n}=r_{N,j}^{\,n}=0\)</span>, so ghost nodes are never used.</p>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="block-matrix-form" class="slide level2 compact-slide">
<h2>Block matrix form</h2>
<p>Stack the two income states as <span class="math display">\[
  \mathbf{v}_j^{\,n} = \big(v_{1,j}^{\,n},\dots,v_{N,j}^{\,n}\big)^\top,\quad
  \mathbf{v}^{\,n} = \big((\mathbf{v}_1^{\,n})^\top,(\mathbf{v}_2^{\,n})^\top\big)^\top,\quad
  \mathbf{u}^{\,n} = \big(u(c_{1,1}^{\,n}),\dots,u(c_{N,2}^{\,n})\big)^\top.
\]</span> Then <span class="math display">\[
  \mathbf{A}^{\,n}\,\mathbf{v}^{\,n+1} \;=\; \frac{1}{\Delta t}\,\mathbf{v}^{\,n} + \mathbf{u}^{\,n},
\]</span> with the <span class="math inline">\(2N\times 2N\)</span> block matrix <span class="math display">\[
  \mathbf{A}^{\,n} \;=\;
  \begin{pmatrix}
    \mathbf{A}_1^{\,n}  &amp; -\,\lambda_1\, \mathbf{I}_N \\
    -\,\lambda_2\, \mathbf{I}_N    &amp; \mathbf{A}_2^{\,n}
  \end{pmatrix}, \qquad \qquad
  \mathbf{A}_j^{\,n} = \begin{pmatrix}
    s_{1,j}^{\,n} &amp; -r_{1,j}^{\,n} &amp; 0 &amp; \ldots &amp; 0 \\
    -\ell_{2,j}^{\,n} &amp; s_{2,j}^{\,n} &amp; -r_{2,j}^{\,n} &amp; \ldots &amp; 0 \\
    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
    0 &amp; \ldots &amp; -\ell_{N-1,j}^{\,n} &amp; s_{N-1,j}^{\,n} &amp; -r_{N-1,j}^{\,n} \\
    0 &amp; \ldots &amp; 0 &amp; -\ell_{N,j}^{\,n} &amp; s_{N,j}^{\,n}
  \end{pmatrix}.
\]</span></p>
<div style="margin-top: 1.5em;">

</div>
<div class="fragment">
<div title="Unconditional stability">
<div class="callout callout-important callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Unconditional stability</strong></p>
</div>
<div class="callout-content">
<p>Off-diagonals of <span class="math inline">\(\mathbf{A}^{\,n}\)</span> are nonpositive and <span class="math inline">\((\text{diag}) - \sum_{\text{offdiag}} |\,\cdot\,|
  = \big[\tfrac{1}{\Delta t} + \rho+\lambda_j + \ell + r\big] - (\ell + r + \lambda_j)
  = \tfrac{1}{\Delta t} + \rho \,&gt;\, 0\)</span>, for each row. Thus <span class="math inline">\(\mathbf{A}^{\,n}\)</span> is an M-matrix, the scheme is monotone and convergent, and it is <span class="text-green"><strong>unconditionally stable</strong></span> (no CFL restriction on <span class="math inline">\(\Delta t\)</span>).</p>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="finite-differences-as-policy-function-iteration" class="slide level2 compact-slide">
<h2>Finite Differences as Policy Function Iteration</h2>
<p>We have seen that the finite-difference method can be interpreted as an application of the MCA method: <span class="math display">\[
  \mathbf{v}
  = \max_{\mathbf{c}}
    \Big\{ u(\mathbf{c})\,\Delta t
    + (1-\rho \Delta t)\,\mathbf{P}(\mathbf{c})\,\mathbf{v} \Big\}
  \;\equiv\; \mathbf{T}\mathbf{v},
\]</span></p>
<div class="fragment">
<p>One can solve this problem using any method for discrete-time dynamic programming.</p>
<ul>
<li>The (semi-implicit) finite-difference scheme of <span class="citation" data-cites="achdou2022income">Achdou et al. (<a href="#/references" role="doc-biblioref" onclick="">2022</a>)</span> is closely related to <span class="text-orange"><strong>policy function iteration (PFI)</strong></span>.</li>
<li>This was pointed out by <span class="citation" data-cites="PhelanEslami2022MCA">Phelan and Eslami (<a href="#/references" role="doc-biblioref" onclick="">2022</a>)</span>.</li>
</ul>
</div>
<div class="fragment">
<div style="background-color: #f5f5f5; padding: 1em; border-left: 4px solid #0072b2; margin: 1em 0; font-size: 0.85em;">
<p><strong>Algorithm: Policy Function Iteration (PFI)</strong></p>
<p><strong>Input:</strong> Initial policy <span class="math inline">\(\mathbf{c}^{(0)}\)</span>, tolerance <code>tol</code></p>
<p><strong>Output:</strong> Value <span class="math inline">\(\mathbf{v}\)</span>, policy <span class="math inline">\(\mathbf{c}\)</span></p>
<p><strong>Initialize:</strong> <span class="math inline">\(n \gets 0\)</span></p>
<p><strong>Repeat</strong> until <span class="math inline">\(\|\mathbf{c}^{(n+1)}-\mathbf{c}^{(n)}\| &lt; \text{tol}\)</span>:</p>
<ol type="1">
<li><p><strong>Policy evaluation:</strong><br>
Solve <span class="math inline">\([I-(1-\rho\Delta t)P(\mathbf{c}^{(n)})]\mathbf{v}^{(n+1)} = \Delta t\,u(\mathbf{c}^{(n)})\)</span>.</p></li>
<li><p><strong>Policy improvement:</strong><br>
<span class="math inline">\(\mathbf{c}^{(n+1)} \gets \arg\max_{\mathbf{c}}\{\Delta t\,u(\mathbf{c})+(1-\rho\Delta t)P(\mathbf{c})\mathbf{v}^{(n)}\}\)</span>.</p></li>
<li><p><span class="math inline">\(n \gets n+1\)</span>.</p></li>
</ol>
<p><strong>Return:</strong> <span class="math inline">\(\mathbf{v}^{(n)},\,\mathbf{c}^{(n)}\)</span></p>
</div>
</div>
</section>
<section id="model-struct" class="slide level2 compact-slide">
<h2>Model struct</h2>
<p>We start by defining the model parameters and the grid.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="income_fluctuations_struct"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="income_fluctuations_struct-1"><a href="#income_fluctuations_struct-1"></a><span class="pp">@kwdef</span> <span class="kw">struct</span> IncomeFluctuationsModel</span>
<span id="income_fluctuations_struct-2"><a href="#income_fluctuations_struct-2"></a>    œÅ<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">0.05</span></span>
<span id="income_fluctuations_struct-3"><a href="#income_fluctuations_struct-3"></a>    r<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">0.03</span></span>
<span id="income_fluctuations_struct-4"><a href="#income_fluctuations_struct-4"></a>    Œ≥<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">2.0</span></span>
<span id="income_fluctuations_struct-5"><a href="#income_fluctuations_struct-5"></a>    Y<span class="op">::</span><span class="dt">Vector{Float64} </span><span class="op">=</span> [<span class="fl">0.1</span>, <span class="fl">0.2</span>]</span>
<span id="income_fluctuations_struct-6"><a href="#income_fluctuations_struct-6"></a>    Œª<span class="op">::</span><span class="dt">Vector{Float64} </span><span class="op">=</span> [<span class="fl">0.02</span>, <span class="fl">0.03</span>]</span>
<span id="income_fluctuations_struct-7"><a href="#income_fluctuations_struct-7"></a>    Wmin<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="op">-</span><span class="fl">0.02</span></span>
<span id="income_fluctuations_struct-8"><a href="#income_fluctuations_struct-8"></a>    Wmax<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">2.0</span></span>
<span id="income_fluctuations_struct-9"><a href="#income_fluctuations_struct-9"></a>    N<span class="op">::</span><span class="dt">Int64 </span><span class="op">=</span> <span class="fl">500</span></span>
<span id="income_fluctuations_struct-10"><a href="#income_fluctuations_struct-10"></a>    Wgrid<span class="op">::</span><span class="dt">LinRange{Float64} </span><span class="op">=</span> <span class="fu">range</span>(Wmin, Wmax, length <span class="op">=</span> N)</span>
<span id="income_fluctuations_struct-11"><a href="#income_fluctuations_struct-11"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
</div>
</section>
<section id="implicit-scheme-implementation" class="slide level2 compact-slide">
<h2>Implicit scheme implementation</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="fd_implicit" data-code-line-numbers="1-38|3-4|5-7|9-16|17-26|27-34|36-37"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="fd_implicit-1"><a href="#fd_implicit-1"></a><span class="kw">function</span> <span class="fu">fd_implicit</span>(m<span class="op">::</span><span class="dt">IncomeFluctuationsModel</span>; Œît<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="cn">Inf</span>, </span>
<span id="fd_implicit-2"><a href="#fd_implicit-2"></a>    tol<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">1e-6</span>, max_iter<span class="op">::</span><span class="dt">Int64 </span><span class="op">=</span> <span class="fl">100</span>, print_residual<span class="op">::</span><span class="dt">Bool </span><span class="op">=</span> <span class="cn">true</span>)</span>
<span id="fd_implicit-3"><a href="#fd_implicit-3"></a>    (; œÅ, r, Œ≥, Y, Œª, Wgrid, Wmin, Wmax, N) <span class="op">=</span> m <span class="co"># unpack parameters</span></span>
<span id="fd_implicit-4"><a href="#fd_implicit-4"></a>    ŒîW <span class="op">=</span> Wgrid[<span class="fl">2</span>] <span class="op">-</span> Wgrid[<span class="fl">1</span>]</span>
<span id="fd_implicit-5"><a href="#fd_implicit-5"></a>    <span class="co"># Initial guess</span></span>
<span id="fd_implicit-6"><a href="#fd_implicit-6"></a>    v <span class="op">=</span> [<span class="fl">1</span><span class="op">/</span>œÅ <span class="op">*</span> (y <span class="op">+</span> r <span class="op">*</span> w)<span class="op">^</span>(<span class="fl">1</span><span class="op">-</span>Œ≥) <span class="op">/</span> (<span class="fl">1</span><span class="op">-</span>Œ≥) for w <span class="kw">in</span> Wgrid, y <span class="kw">in</span> Y] </span>
<span id="fd_implicit-7"><a href="#fd_implicit-7"></a>    c, vW, residual <span class="op">=</span> <span class="fu">similar</span>(v), <span class="fu">similar</span>(v), <span class="fl">0.0</span> <span class="co"># pre-allocation</span></span>
<span id="fd_implicit-8"><a href="#fd_implicit-8"></a>    <span class="cf">for</span> i <span class="op">=</span> <span class="fl">1</span><span class="op">:</span>max_iter</span>
<span id="fd_implicit-9"><a href="#fd_implicit-9"></a>        <span class="co"># Compute derivatives</span></span>
<span id="fd_implicit-10"><a href="#fd_implicit-10"></a>        Dv <span class="op">=</span> (v[<span class="fl">2</span><span class="op">:</span><span class="kw">end</span>,<span class="op">:</span>] <span class="op">-</span> v[<span class="fl">1</span><span class="op">:</span><span class="kw">end</span><span class="op">-</span><span class="fl">1</span>,<span class="op">:</span>]) <span class="op">/</span> ŒîW</span>
<span id="fd_implicit-11"><a href="#fd_implicit-11"></a>        vB <span class="op">=</span> [(@. (r <span class="op">*</span> Wmin <span class="op">+</span> Y)<span class="op">^</span>(<span class="op">-</span>Œ≥))<span class="ch">'; Dv] # backward difference</span></span>
<span id="fd_implicit-12"><a href="#fd_implicit-12"></a>        vF <span class="op">=</span> [Dv; (@. (r <span class="op">*</span> Wmax <span class="op">+</span> Y)<span class="op">^</span>(<span class="op">-</span>Œ≥))<span class="ch">'] # forward difference</span></span>
<span id="fd_implicit-13"><a href="#fd_implicit-13"></a>        vÃÖ  <span class="op">=</span> (r <span class="op">*</span> Wgrid <span class="op">.+</span> Y<span class="op">'</span>)<span class="op">.^</span>(<span class="op">-</span>Œ≥) <span class="co"># zero-savings case</span></span>
<span id="fd_implicit-14"><a href="#fd_implicit-14"></a>        ŒºB <span class="op">=</span> r <span class="op">*</span> Wgrid <span class="op">.+</span> Y<span class="op">'</span> <span class="op">-</span> vB<span class="op">.^</span>(<span class="op">-</span><span class="fl">1</span><span class="op">/</span>Œ≥) <span class="co"># backward drift</span></span>
<span id="fd_implicit-15"><a href="#fd_implicit-15"></a>        ŒºF <span class="op">=</span> r <span class="op">*</span> Wgrid <span class="op">.+</span> Y<span class="op">'</span> <span class="op">-</span> vF<span class="op">.^</span>(<span class="op">-</span><span class="fl">1</span><span class="op">/</span>Œ≥) <span class="co"># forward drift</span></span>
<span id="fd_implicit-16"><a href="#fd_implicit-16"></a>        vW <span class="op">=</span> <span class="fu">ifelse</span>.(ŒºF <span class="op">.&gt;</span> <span class="fl">0.0</span>, vF, <span class="fu">ifelse</span>.(ŒºB <span class="op">.&lt;</span> <span class="fl">0.0</span>, vB, vÃÖ))</span>
<span id="fd_implicit-17"><a href="#fd_implicit-17"></a>        <span class="co"># Assemble matrix</span></span>
<span id="fd_implicit-18"><a href="#fd_implicit-18"></a>        c  <span class="op">=</span> vW<span class="op">.^</span>(<span class="op">-</span><span class="fl">1</span><span class="op">/</span>Œ≥)          <span class="co"># consumption</span></span>
<span id="fd_implicit-19"><a href="#fd_implicit-19"></a>        u  <span class="op">=</span> c<span class="op">.^</span>(<span class="fl">1</span><span class="op">-</span>Œ≥) <span class="op">/</span> (<span class="fl">1</span><span class="op">-</span>Œ≥)    <span class="co"># utility</span></span>
<span id="fd_implicit-20"><a href="#fd_implicit-20"></a>        L <span class="op">=</span> <span class="fu">-min</span>.(ŒºB, <span class="fl">0</span>) <span class="op">/</span> ŒîW    <span class="co"># subdiagonal</span></span>
<span id="fd_implicit-21"><a href="#fd_implicit-21"></a>        R <span class="op">=</span> <span class="fu">max</span>.(ŒºF, <span class="fl">0</span>) <span class="op">/</span> ŒîW     <span class="co"># superdiagonal</span></span>
<span id="fd_implicit-22"><a href="#fd_implicit-22"></a>        S <span class="op">=</span> @. <span class="fl">1</span><span class="op">/</span>Œît <span class="op">+</span> L <span class="op">+</span> R <span class="op">+</span> œÅ <span class="op">+</span> Œª<span class="ch">' # diagonal</span></span>
<span id="fd_implicit-23"><a href="#fd_implicit-23"></a>        Aj <span class="op">=</span> [<span class="fu">Tridiagonal</span>(<span class="op">-</span>L[<span class="fl">2</span><span class="op">:</span><span class="kw">end</span>,j], S[<span class="op">:</span>,j], <span class="op">-</span>R[<span class="fl">1</span><span class="op">:</span><span class="kw">end</span><span class="op">-</span><span class="fl">1</span>,j]) </span>
<span id="fd_implicit-24"><a href="#fd_implicit-24"></a>                for j <span class="kw">in</span> <span class="fu">eachindex</span>(Y)] <span class="co"># tridiagonal matrices</span></span>
<span id="fd_implicit-25"><a href="#fd_implicit-25"></a>        A <span class="op">=</span> [<span class="fu">sparse</span>(Aj[<span class="fl">1</span>]) <span class="op">-</span>Œª[<span class="fl">1</span>] <span class="op">*</span> I</span>
<span id="fd_implicit-26"><a href="#fd_implicit-26"></a>            <span class="op">-</span>Œª[<span class="fl">2</span>] <span class="op">*</span> I <span class="fu">sparse</span>(Aj[<span class="fl">2</span>])] <span class="co"># block matrix</span></span>
<span id="fd_implicit-27"><a href="#fd_implicit-27"></a>        <span class="co"># Update</span></span>
<span id="fd_implicit-28"><a href="#fd_implicit-28"></a>        vp <span class="op">=</span> A <span class="op">\</span> (u <span class="op">+</span> v<span class="op">/</span>Œît)[<span class="op">:</span>]</span>
<span id="fd_implicit-29"><a href="#fd_implicit-29"></a>        residual <span class="op">=</span> <span class="fu">sqrt</span>(<span class="fu">mean</span>((vp <span class="op">-</span> v[<span class="op">:</span>])<span class="op">.^</span><span class="fl">2</span>)) </span>
<span id="fd_implicit-30"><a href="#fd_implicit-30"></a>        v <span class="op">=</span> <span class="fu">reshape</span>(vp, N, <span class="fu">length</span>(Y)) <span class="co"># reshape vector to matrix</span></span>
<span id="fd_implicit-31"><a href="#fd_implicit-31"></a>        if print_residual <span class="fu">println</span>(<span class="st">"Iteration </span><span class="sc">$</span>i<span class="st">, residual = </span><span class="sc">$</span>residual<span class="st">"</span>) <span class="kw">end</span></span>
<span id="fd_implicit-32"><a href="#fd_implicit-32"></a>        if residual <span class="op">&lt;</span> tol</span>
<span id="fd_implicit-33"><a href="#fd_implicit-33"></a>            break</span>
<span id="fd_implicit-34"><a href="#fd_implicit-34"></a>        <span class="kw">end</span></span>
<span id="fd_implicit-35"><a href="#fd_implicit-35"></a>    <span class="kw">end</span></span>
<span id="fd_implicit-36"><a href="#fd_implicit-36"></a>    s <span class="op">=</span> r <span class="op">*</span> Wgrid <span class="op">.+</span> Y<span class="op">'</span> <span class="op">-</span> c   <span class="co"># savings</span></span>
<span id="fd_implicit-37"><a href="#fd_implicit-37"></a>    return (; v, vW, c, s, residual) <span class="co"># return solution</span></span>
<span id="fd_implicit-38"><a href="#fd_implicit-38"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="the-solution-to-the-income-fluctuations-problem" class="slide level2 compact-slide">
<h2>The Solution to the Income Fluctuations Problem</h2>
<div class="columns">
<div class="column" style="width:50%;">
<p><img data-src="Figures/income_fluctuations_value_function.png" style="width:80.0%"></p>
</div><div class="column" style="width:50%;">
<p><img data-src="Figures/income_fluctuations_MPC.png" style="width:80.0%"></p>
</div></div>
<!-- . . .

<div style="margin-top: 1.0em;"></div> -->
<div class="columns">
<div class="column" style="width:50%;">
<p><img data-src="Figures/income_fluctuations_consumption_function.png" style="width:80.0%"></p>
</div><div class="column" style="width:50%;">
<p><img data-src="Figures/income_fluctuations_savings.png" style="width:80.0%"></p>
</div></div>
</section></section>
<section>
<section id="iv.-spectral-methods" class="title-slide slide level1 center">
<h1>IV. Spectral Methods</h1>

</section>
<section id="finite-differences-as-local-polynomial-approximations" class="slide level2 compact-slide">
<h2>Finite differences as local polynomial approximations</h2>
<p>We have used finite differences to generate a <em>local approximation</em> of derivatives, based on function values at neighboring points.</p>
<ul>
<li>We will see how to use <span class="text-orange"><strong>spectral methods</strong></span>, which instead provide a <em>global approximation</em> of derivatives.</li>
<li>We are interested in computing the derivative of a function <span class="math inline">\(v(x)\)</span> that we observe at discrete points <span class="math inline">\(\{x_i\}_{i=1}^N\)</span>.</li>
</ul>
<div class="fragment">
<div style="border-top: 1px solid #ccc; margin: 1em 0;">

</div>
<div class="columns">
<div class="column" style="width:50%;">
<p>A natural approximation is the <span class="text-blue"><strong>forward difference</strong></span>: <span class="math display">\[
  v'(x_i) = \frac{v_{i+1}-v_i}{\Delta x}+ O(\Delta x).
\]</span></p>
</div><div class="column" style="width:50%;">
<p>This is equivalent to replacing <span class="math inline">\(v(x)\)</span> locally by a <em>linear interpolant</em>:</p>
<p><span class="math display">\[
\tilde v(x) = v_i + Dv_i (x-x_i), \qquad Dv_i = \frac{v_{i+1}-v_i}{\Delta x}.
\]</span></p>
</div></div>
<p>Differentiating the interpolant yields <span class="math inline">\(\tilde v'(x_i)=Dv_i\)</span>, i.e., the forward difference.</p>
<div style="border-top: 1px solid #ccc; margin: 1em 0;">

</div>
</div>
<div class="fragment">
<div class="columns">
<div class="column" style="width:50%;">
<p>The <span class="text-green"><strong>central difference formula</strong></span> yields <span class="math display">\[
  v'(x_i) = \frac{v_{i+1}-v_{i-1}}{2\Delta x} + O(\Delta x^2),
\]</span></p>
</div><div class="column" style="width:50%;">
<p>This is equivalent to replacing <span class="math inline">\(v(x)\)</span> by a <em>quadratic interpolant</em>:</p>
<p><span class="math display">\[
\tilde v(x) = \ell_{i-1}(x)v_{i-1} + \ell_i(x)v_i + \ell_{i+1}(x)v_{i+1},
\]</span></p>
</div></div>
<p>where the basis polynomials are <span class="math inline">\(\ell_{i-1}(x) = \frac{(x-x_i)(x-x_{i+1})}{2\Delta x^2}\)</span>, <span class="math inline">\(\ell_i(x) = -\frac{(x-x_i+\Delta x)(x-x_i-\Delta x)}{\Delta x^2}\)</span>, and <span class="math inline">\(\ell_{i+1}(x) = \frac{(x-x_i+\Delta x)(x-x_i)}{2\Delta x^2}\)</span>.</p>
</div>
<div class="fragment">
<p>Differentiating and evaluating at <span class="math inline">\(x_i\)</span> yields the central difference formulas: <span class="math display">\[
  \tilde v'(x_i) = \frac{v_{i+1}-v_{i-1}}{2\Delta x},
  \qquad
  \tilde v''(x_i) = \frac{v_{i+1}-2v_i+v_{i-1}}{\Delta x^2},
\]</span></p>
<div style="border-top: 1px solid #ccc; margin: 1em 0;">

</div>
</div>
</section>
<section id="higher-order-finite-differences" class="slide level2 compact-slide">
<h2>Higher-order finite differences</h2>
<p>We can obtain higher-order finite-difference formulas by fitting higher-degree local polynomials and differentiating them.</p>
<ul>
<li>For example, a quartic interpolant yields a fourth-order approximation to <span class="math inline">\(v'(x_i)\)</span>.</li>
<li>We can compute such higher-order approximations in Julia using the <code>Polynomials.jl</code> package.</li>
</ul>
<div style="margin-top: 1.5em;">

</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="finite_difference_fun" data-code-line-numbers="1-21"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="finite_difference_fun-1"><a href="#finite_difference_fun-1"></a><span class="st">"""</span></span>
<span id="finite_difference_fun-2"><a href="#finite_difference_fun-2"></a><span class="st">    finite_difference(f, x0, accuracy; scheme=:forward, Œîx=0.01)</span></span>
<span id="finite_difference_fun-3"><a href="#finite_difference_fun-3"></a></span>
<span id="finite_difference_fun-4"><a href="#finite_difference_fun-4"></a><span class="st">Approximate f'(x0) by differentiating a local interpolating </span></span>
<span id="finite_difference_fun-5"><a href="#finite_difference_fun-5"></a><span class="st">polynomial built on a stencil that achieves the requested accuracy.</span></span>
<span id="finite_difference_fun-6"><a href="#finite_difference_fun-6"></a><span class="st">"""</span></span>
<span id="finite_difference_fun-7"><a href="#finite_difference_fun-7"></a><span class="kw">function</span> <span class="fu">finite_difference</span>(f<span class="op">::</span><span class="dt">Function</span>, x0<span class="op">::</span><span class="dt">Float64</span>, accuracy<span class="op">::</span><span class="dt">Int</span>;</span>
<span id="finite_difference_fun-8"><a href="#finite_difference_fun-8"></a>                    scheme<span class="op">::</span><span class="dt">Symbol </span><span class="op">=</span> <span class="op">:</span>forward, Œîx<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">0.01</span>)</span>
<span id="finite_difference_fun-9"><a href="#finite_difference_fun-9"></a>    <span class="pp">@assert</span> accuracy <span class="op">&gt;</span> <span class="fl">0</span> <span class="st">"accuracy order must be positive"</span></span>
<span id="finite_difference_fun-10"><a href="#finite_difference_fun-10"></a>    steps <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Int</span>, accuracy<span class="op">+</span><span class="fl">1</span>)</span>
<span id="finite_difference_fun-11"><a href="#finite_difference_fun-11"></a>    <span class="cf">if</span> <span class="fu">iseven</span>(accuracy)</span>
<span id="finite_difference_fun-12"><a href="#finite_difference_fun-12"></a>        m <span class="op">=</span> accuracy <span class="op">√∑</span> <span class="fl">2</span></span>
<span id="finite_difference_fun-13"><a href="#finite_difference_fun-13"></a>        steps <span class="op">=</span> <span class="fu">collect</span>(<span class="op">-</span>m<span class="op">:</span>m)</span>
<span id="finite_difference_fun-14"><a href="#finite_difference_fun-14"></a>    <span class="cf">else</span></span>
<span id="finite_difference_fun-15"><a href="#finite_difference_fun-15"></a>        q <span class="op">=</span> accuracy</span>
<span id="finite_difference_fun-16"><a href="#finite_difference_fun-16"></a>        steps <span class="op">=</span> scheme <span class="op">===</span> <span class="op">:</span>forward ? <span class="fu">collect</span>(<span class="fl">0</span><span class="op">:</span>q) <span class="op">:</span> <span class="fu">collect</span>(<span class="op">-</span>q<span class="op">:</span><span class="fl">0</span>)</span>
<span id="finite_difference_fun-17"><a href="#finite_difference_fun-17"></a>    <span class="cf">end</span></span>
<span id="finite_difference_fun-18"><a href="#finite_difference_fun-18"></a>    x_points <span class="op">=</span> x0 <span class="op">.+</span> Œîx <span class="op">.*</span> steps</span>
<span id="finite_difference_fun-19"><a href="#finite_difference_fun-19"></a>    p    <span class="op">=</span> Polynomials.<span class="fu">fit</span>(x_points, <span class="fu">f</span>.(x_points), <span class="fu">length</span>(x_points) <span class="op">-</span> <span class="fl">1</span>)</span>
<span id="finite_difference_fun-20"><a href="#finite_difference_fun-20"></a>    <span class="cf">return</span> Polynomials.<span class="fu">derivative</span>(p)(x0)</span>
<span id="finite_difference_fun-21"><a href="#finite_difference_fun-21"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section></section>
<section>
<section id="truncation-vs.-roundoff-error" class="title-slide slide level1 compact-slide center">
<h1>Truncation vs.&nbsp;Roundoff Error</h1>
<p>One would expect that the error of the finite-difference approximation decreases as the grid is refined (<span class="math inline">\(\Delta x \to 0\)</span>).</p>
<ul>
<li>However, eventually the error increases again as <span class="math inline">\(\Delta x\)</span> becomes very small.</li>
<li>This is due to the interplay of <em>truncation error</em> and <em>roundoff error</em>.</li>
</ul>

<img data-src="Figures/finite_difference_error2.png" style="width:100.0%" class="r-stretch"></section>
<section id="from-local-to-global-polynomials" class="slide level2 compact-slide">
<h2>From local to global polynomials</h2>
<p>Suppose we approximate a smooth function <span class="math inline">\(v(x)\)</span> on <span class="math inline">\([-1,1]\)</span> by a single polynomial of degree <span class="math inline">\(N\)</span>: <span class="math display">\[\begin{equation}
  v(x) \approx \tilde v_N(x) = \sum_{k=0}^{N} a_k x^k,
\end{equation}\]</span> where the coefficients <span class="math inline">\(a_k\)</span> are chosen so that <span class="math inline">\(\tilde v_N(x_i) = v(x_i)\)</span> at a set of interpolation nodes <span class="math inline">\(\{x_i\}_{i=0}^N\)</span>.</p>
<div class="fragment">
<div title="Change of domain">
<div class="callout callout-tip callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Change of domain</strong></p>
</div>
<div class="callout-content">
<p>When approximating a function <span class="math inline">\(v(x)\)</span> on a bounded domain <span class="math inline">\([a,b]\)</span>, we can always map it to the interval <span class="math inline">\([-1,1]\)</span> via <span class="math display">\[
    v(x) \equiv V\!\left(\tfrac{(b-a)x + (a+b)}{2}\right),
    \qquad x \in [-1,1].
  \]</span> For a discussion of approximations on unbounded domains, see Chapter 17 of <span class="citation" data-cites="Boyd2001">Boyd (<a href="#/references" role="doc-biblioref" onclick="">2001</a>)</span>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="fragment">
<div title="Finite vs. spectral accuracy">
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Finite vs.&nbsp;spectral accuracy</strong></p>
</div>
<div class="callout-content">
<p>Higher-order finite differences improve accuracy algebraically, with error <span class="math inline">\(O(\Delta x^p)\)</span> for a <span class="math inline">\(p\)</span>-th order scheme.</p>
<ul>
<li>In contrast, spectral methods achieve <em>exponential</em> (or <em>spectral</em>) convergence for smooth functions, as we will see next.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="the-runge-phenomenon" class="slide level2 compact-slide">
<h2>The Runge phenomenon</h2>
<p>This global approach uses information from the entire domain to approximate derivatives or other operators.</p>
<ul>
<li>However, if the interpolation nodes <span class="math inline">\(x_i\)</span> are <em>equally spaced</em>, the interpolant may oscillate violently near the boundaries as <span class="math inline">\(N\)</span> increases</li>
<li>A pathology known as the <span class="text-orange"><strong>Runge phenomenon</strong></span>: consider the function <span class="math inline">\(v(x) = \frac{1}{1 + 25x^2}\)</span>, for <span class="math inline">\(x \in [-1,1]\)</span>.</li>
</ul>
<div class="fragment">
<div style="margin-top: 1.0em;">

</div>
<p><img data-src="Figures/runge_phenomenon.png" style="width:77.0%"></p>
</div>
</section>
<section id="the-interpolation-error-theorem" class="slide level2 compact-slide">
<h2>The interpolation error theorem</h2>
<p>The <span class="text-orange"><strong>interpolation error theorem</strong></span> <a href="https://en.wikipedia.org/wiki/Polynomial_interpolation" class="about-link">üåê</a> provides a useful decomposition of the interpolation error.</p>
<ul>
<li>Let <span class="math inline">\(v(x)\)</span> have at least <span class="math inline">\(N+1\)</span> derivatives on <span class="math inline">\([-1,1]\)</span> and let <span class="math inline">\(\tilde v_N(x)\)</span> be the degree-<span class="math inline">\(N\)</span> interpolant of <span class="math inline">\(v(x)\)</span> at nodes <span class="math inline">\(\{x_i\}_{i=0}^N\)</span>.</li>
<li>Then, the interpolation error is given by <span class="math display">\[
v(x) - \tilde v_N(x)
= \color{#0072b2}{\frac{v^{(N+1)}(\xi)}{(N+1)!}}\,\color{#009e73}{\mathcal{P}_{N+1}(x)},
\qquad
\mathcal{P}_{N+1}(x) = \prod_{i=0}^{N}(x - x_i),
\]</span> for some <span class="math inline">\(\xi \in [-1,1]\)</span>.</li>
</ul>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<p>The error therefore depends on two components:</p>
<ul>
<li>The <span class="math inline">\((N+1)\)</span>-st derivative <span class="math inline">\(v^{(N+1)}(\xi)\)</span>, which depends only on the smoothness of <span class="math inline">\(v\)</span>; and</li>
<li>The <em>node polynomial</em> <span class="math inline">\(\mathcal{P}_{N+1}(x)\)</span>, which depends solely on the choice of interpolation nodes.</li>
</ul>
</div>
<div class="fragment">
<p>We cannot control the smoothness of <span class="math inline">\(v\)</span>, but we <em>can</em> control the second term.</p>
<div title="Worst-case interpolation error">
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Worst-case interpolation error</strong></p>
</div>
<div class="callout-content">
<p>The worst-case (uniform) interpolation error is bounded by <span class="math display">\[
  |v(x) - \tilde v_N(x)|
  \le
  \frac{1}{(N+1)!}\,
  \max_{x \in [-1,1]} |v^{(N+1)}(x)|\,
  \|\mathcal{P}_{N+1} \|_\infty,
  \qquad
  \|\mathcal{P}_{N+1} \|_\infty \equiv \max_{x \in [-1,1]} |\mathcal{P}_{N+1}(x)|.
\]</span></p>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="chebyshev-polynomials-and-the-minimax-property" class="slide level2 compact-slide">
<h2>Chebyshev polynomials and the minimax property</h2>
<p>Our goal is clear: choose interpolation nodes <span class="math inline">\(\{x_i\}\)</span> that minimize <span class="math inline">\(\|\mathcal{P}_{N+1}\|_\infty\)</span>.</p>
<ul>
<li>This leads directly to the <span class="text-orange"><strong>Chebyshev minimal amplitude theorem</strong></span>.</li>
</ul>
<div class="fragment">
<div title="Chebyshev minimal amplitude theorem">
<div class="callout callout-important callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Chebyshev minimal amplitude theorem</strong></p>
</div>
<div class="callout-content">
<p>Define the <em>Chebyshev nodes</em><a href="https://en.wikipedia.org/wiki/Chebyshev_nodes" class="about-link">üåê</a> as <span class="math display">\[
  \hat{x}_i = \cos\!\left(\frac{(2i+1)\pi}{2(N+1)}\right),
  \qquad i = 0,\ldots,N.
\]</span> The polynomial <span class="math inline">\(\mathcal{P}_{N+1}(x) = \prod_{i=0}^{N} (x - x_i)\)</span> attains its smallest maximum amplitude on <span class="math inline">\([-1,1]\)</span> when the <span class="math inline">\(x_i\)</span> are the Chebyshev nodes: <span class="math display">\[
  \|\mathcal{P}_{N+1}\|_\infty
  = \max_{x \in [-1,1]} |\mathcal{P}_{N+1}(x)|
  \geq
  \max_{x \in [-1,1]} \left|\prod_{i=0}^{N} (x - \hat{x}_i)\right|.
\]</span></p>
</div>
</div>
</div>
</div>
</div>
<div class="fragment">
<div class="columns">
<div class="column" style="width:50%;">
<p>Chebyshev nodes are the roots of the <span class="text-blue"><strong>Chebyshev polynomial</strong></span> <a href="https://en.wikipedia.org/wiki/Chebyshev_polynomials" class="about-link">üåê</a>, <span class="math display">\[
  T_{N+1}(x) = \cos\!\big((N+1)\arccos x\big),
\]</span> which oscillates between <span class="math inline">\(-1\)</span> and <span class="math inline">\(1\)</span> exactly <span class="math inline">\(N{+}2\)</span> times on <span class="math inline">\([-1,1]\)</span>.</p>
</div><div class="column" style="width:50%;">
<p>Chebyshev polynomials enjoy an <span class="text-green"><strong>orthogonality relation</strong></span>: <span class="math display">\[
  \int_{-1}^1 T_m(x)\,T_n(x)\,w(x)\,dx =
0, \qquad m \ne n, \qquad w(x)=1/\sqrt{1-x^2}.
\]</span></p>
</div></div>
</div>
</section>
<section id="from-interpolation-to-differentiation" class="slide level2 compact-slide">
<h2>From interpolation to differentiation</h2>
<p>Let <span class="math inline">\(\tilde v_N(x) = \sum_{k=0}^N a_k T_k(x)\)</span> be the degree-<span class="math inline">\(N\)</span> Chebyshev interpolant of <span class="math inline">\(v(x)\)</span>:</p>
<ul>
<li>Given the interpolant, it is straightforward to compute its derivatives.</li>
<li>One can use recursion for Chebyshev polynomials of the second kind or the formulas in the lecture notes.</li>
</ul>
<div class="fragment">
<div class="columns">
<div class="column" style="width:50%;">
<p><img data-src="Figures/spectral_error.png" style="width:100.0%"></p>
</div><div class="column" style="width:50%;">
<p>Consider the smooth function <span class="math inline">\(v(x) = e^{x^2} + 2\sin(x)\)</span>:</p>
<ul>
<li>The figure shows the approximation error for the derivative</li>
<li>We compare finite differences and Chebyshev differentiation</li>
</ul>
<div style="margin-top: 1.0em;">

</div>
<p>Chebyshev differentiation reaches machine precision accuracy</p>
<ul>
<li>With a modest number of nodes (around <span class="math inline">\(N=20\)</span>)</li>
<li>Even with <span class="math inline">\(N = 10\)</span>, it is orders of magnitude more accurate than FD</li>
</ul>
</div></div>
</div>
<div class="fragment">
<div title="Derivatives of Chebyshev polynomials">
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Derivatives of Chebyshev polynomials</strong></p>
</div>
<div class="callout-content">
<p>Because the Chebyshev interpolation error decays exponentially for smooth functions, the same holds for the derivative approximation: <span class="math display">\[
  \|\tilde v_N'(x) - v'(x)\|_\infty = O(e^{-\alpha N}), \qquad \text{for some } \alpha &gt;0.
  \]</span></p>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="the-two-trees-model" class="slide level2 compact-slide">
<h2>The Two-trees Model</h2>
<p>We can use Chebyshev polynomials to solve PDEs like the HJB equation</p>
<ul>
<li>To illustrate the method, we consider the <span class="text-orange"><strong>two-trees model</strong></span> of <span class="citation" data-cites="CochraneLongstaffSantaClara2008">Cochrane, Longstaff, and Santa-Clara (<a href="#/references" role="doc-biblioref" onclick="">2008</a>)</span></li>
<li>The model is a two-tree economy with dividends following a geometric Brownian motion: <span class="math display">\[
\frac{d D_{i,t}}{D_{i,t}} = \mu dt + \sigma dB_{i,t}, \qquad i = 1,2.
\]</span></li>
</ul>
<div class="fragment">
<p>Aggregate consumption equals the sum of dividends from the two trees: <span class="math inline">\(C_t = D_{1,t} + D_{2,t}\)</span>.</p>
<ul>
<li>Assuming the representative household has log utility, the price of the first tree is given by: <span class="math display">\[
P_{t} = \mathbb{E}_t \left[ \int_{0}^{\infty} e^{-\rho s} \frac{C_t}{C_{t+s}} D_{1,t+s} ds \right] \Rightarrow v_{t} = \mathbb{E}_t \left[ \int_{0}^{\infty} e^{-\rho s} s_{t+s} ds \right], \qquad v_t \equiv \frac{P_t}{C_t}, \qquad s_t \equiv \frac{D_{1,t}}{C_{t}}.
\]</span></li>
</ul>
</div>
<div class="fragment">
<div title="The HJB equation">
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>The HJB equation</strong></p>
</div>
<div class="callout-content">
<p>The price-consumption ratio <span class="math inline">\(v_t\)</span> satisfies the <span class="text-green"><strong>HJB equation</strong></span>: <span class="math display">\[
  \rho v = s - v_s \,2\sigma^2 s(1-s)\!\left(s-\tfrac12\right)
           + \frac{1}{2} v_{ss}\,\big(2\sigma^2 s^2(1-s)^2\big),
\]</span> with boundary conditions <span class="math inline">\(v(0) = 0\)</span> and <span class="math inline">\(v(1) = 1/\rho\)</span>, using <span class="math inline">\(d s_t = - 2 \sigma^2 s_t(1-s_t)(s_t -1/2) dt + \sigma s_t(1-s_t)(dB_{1,t}- dB_{2,t})\)</span>.</p>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="solving-the-hjb-equation-with-chebyshev-collocation" class="slide level2 compact-slide">
<h2>Solving the HJB equation with Chebyshev collocation</h2>
<p>To solve the HJB equation with Chebyshev collocation, we start with a series expansion of <span class="math inline">\(v(s)\)</span>: <span class="math display">\[
  v(s) = \sum_{n=0}^{\infty} a_n \tilde{T}_n(s) \approx \sum_{n=0}^{N} a_n \tilde{T}_n(s), \qquad \qquad \tilde{T}_n(s) = T_n(2s-1).
\]</span></p>
<div title="Change of domain">
<div class="callout callout-tip callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Change of domain</strong></p>
</div>
<div class="callout-content">
<p>The mapping <span class="math inline">\(s \mapsto x=2s-1\)</span> rescales the domain from <span class="math inline">\([0,1]\)</span> to <span class="math inline">\([-1,1]\)</span>, allowing the use of <em>standard Chebyshev polynomials</em>. Derivatives with respect to <span class="math inline">\(s\)</span> follow from the chain rule, yielding <span class="math inline">\(\tilde T_n'(s)=2T_n'(2s-1)\)</span> and <span class="math inline">\(\tilde T_n''(s)=4T_n''(2s-1)\)</span>.</p>
</div>
</div>
</div>
</div>
<div class="fragment">
<p>Plugging the expansion into the HJB equation and evaluating at the grid points, we obtain the <em>linear system</em>: <span class="math display">\[
  \mathbf{L} \mathbf{a} = \mathbf{b},
\]</span> where <span class="math inline">\(\mathbf{L}\)</span> is a <span class="math inline">\((N+1) \times (N+1)\)</span> matrix and <span class="math inline">\(\mathbf{b}\)</span> is a <span class="math inline">\((N+1)\)</span> vector.</p>
</div>
<div class="fragment">
<p><span class="text-blue"><strong>Interior points.</strong></span> For <span class="math inline">\(i =2,\ldots,N\)</span> and <span class="math inline">\(j = 1,\ldots,N+1\)</span>, we have: <span class="math display">\[
  \mathbf{L}_{i,j} \;=\;
\rho\,\tilde T_{j-1}(s_i)
\;+\; 2\sigma^2 s_i(1-s_i)\!\left(s_i-\tfrac12\right)\,\tilde T_{j-1}'(s_i)
\;-\; \sigma^2 s_i^2(1-s_i)^2\,\tilde T_{j-1}''(s_i), \qquad \qquad b_i = s_i.
\]</span></p>
</div>
<div class="fragment">
<div title="Boundary conditions">
<div class="callout callout-important callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Boundary conditions</strong></p>
</div>
<div class="callout-content">
<p>The first and last rows accommodate the boundary conditions: <span class="math display">\[
\begin{align}
  \mathbf{L}_{1,j} &amp;= \tilde{T}_{j-1}(0), \qquad  
  \mathbf{L}_{N+1,j} = \tilde{T}_{j-1}(1), \qquad \qquad  b_1 = 0, \qquad b_{N+1} = 1/\rho.
\end{align}
\]</span></p>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="julia-implementation-2" class="slide level2 compact-slide">
<h2>Julia Implementation</h2>
<p>We start by defining the model structure for the two-trees model:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="chebyshev_solver"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="chebyshev_solver-1"><a href="#chebyshev_solver-1"></a><span class="pp">@kwdef</span> <span class="kw">struct</span> TwoTrees</span>
<span id="chebyshev_solver-2"><a href="#chebyshev_solver-2"></a>    œÅ<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">0.04</span></span>
<span id="chebyshev_solver-3"><a href="#chebyshev_solver-3"></a>    œÉ<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fu">sqrt</span>(<span class="fl">0.04</span>)</span>
<span id="chebyshev_solver-4"><a href="#chebyshev_solver-4"></a>    Œº<span class="op">::</span><span class="dt">Float64 </span><span class="op">=</span> <span class="fl">0.02</span></span>
<span id="chebyshev_solver-5"><a href="#chebyshev_solver-5"></a>    N<span class="op">::</span><span class="dt">Int </span><span class="op">=</span> <span class="fl">7</span></span>
<span id="chebyshev_solver-6"><a href="#chebyshev_solver-6"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="fragment">
<p>To construct the matrix <span class="math inline">\(\mathbf{L}\)</span>, we need to evaluate the Chebyshev polynomials and their derivatives at the grid points:</p>
<ul>
<li>We use the implementation of Chebyshev polynomials and their derivatives from the <code>Polynomials.jl</code> package.</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="chebyshev_derivatives" data-code-line-numbers="1-9|3-4|5|6-7|8"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="chebyshev_derivatives-1"><a href="#chebyshev_derivatives-1"></a><span class="kw">function</span> <span class="fu">chebyshev_derivatives</span>(n<span class="op">::</span><span class="dt">Int</span>, z<span class="op">::</span><span class="dt">Real</span>; </span>
<span id="chebyshev_derivatives-2"><a href="#chebyshev_derivatives-2"></a>        zmin<span class="op">::</span><span class="dt">Real </span><span class="op">=</span> <span class="op">-</span><span class="fl">1.0</span>, zmax<span class="op">::</span><span class="dt">Real </span><span class="op">=</span> <span class="fl">1.0</span>)</span>
<span id="chebyshev_derivatives-3"><a href="#chebyshev_derivatives-3"></a>    a, b <span class="op">=</span> <span class="fl">2</span> <span class="op">/</span> (zmax <span class="op">-</span> zmin), <span class="fu">-</span>(zmin <span class="op">+</span> zmax) <span class="op">/</span> (zmax <span class="op">-</span> zmin)</span>
<span id="chebyshev_derivatives-4"><a href="#chebyshev_derivatives-4"></a>    x <span class="op">=</span> a <span class="op">*</span> z <span class="op">+</span> b <span class="co"># Map to [-1,1]</span></span>
<span id="chebyshev_derivatives-5"><a href="#chebyshev_derivatives-5"></a>    p <span class="op">=</span> <span class="fu">ChebyshevT</span>([<span class="fu">zeros</span>(n);<span class="fl">1.0</span>]) <span class="co"># Degree n Chebyshev polynomial</span></span>
<span id="chebyshev_derivatives-6"><a href="#chebyshev_derivatives-6"></a>    d1p <span class="op">=</span> <span class="fu">derivative</span>(p) <span class="co"># First derivative</span></span>
<span id="chebyshev_derivatives-7"><a href="#chebyshev_derivatives-7"></a>    d2p <span class="op">=</span> <span class="fu">derivative</span>(d1p) <span class="co"># Second derivative</span></span>
<span id="chebyshev_derivatives-8"><a href="#chebyshev_derivatives-8"></a>    <span class="cf">return</span> <span class="fu">p</span>(x), <span class="fu">d1p</span>(x) <span class="op">*</span> a, <span class="fu">d2p</span>(x) <span class="op">*</span> a<span class="op">^</span><span class="fl">2</span></span>
<span id="chebyshev_derivatives-9"><a href="#chebyshev_derivatives-9"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="the-chebyshev-solver" class="slide level2 compact-slide">
<h2>The Chebyshev solver</h2>
<p>The function <code>chebyshev_solver</code> solves for the coefficients <span class="math inline">\(a_n\)</span> of the Chebyshev expansion of the price-consumption ratio <span class="math inline">\(v(s)\)</span>:</p>
<ul>
<li>The function returns a <code>NamedTuple</code> with the function <span class="math inline">\(v(s)\)</span> and the grid <span class="math inline">\(s_i\)</span>.</li>
<li>Notice that the function <span class="math inline">\(v(s)\)</span> can be evaluated at any point in the interval <span class="math inline">\([z_{\min},z_{\max}]\)</span>, not just the grid points.</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="chebyshev_solver" data-code-line-numbers="1-21|3-5|6-7|9-16|18-20|1-21"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="chebyshev_solver-1"><a href="#chebyshev_solver-1"></a><span class="kw">function</span> <span class="fu">chebyshev_solver</span>(m<span class="op">::</span><span class="dt">TwoTrees</span>)</span>
<span id="chebyshev_solver-2"><a href="#chebyshev_solver-2"></a>    (; œÅ, œÉ, N) <span class="op">=</span> m</span>
<span id="chebyshev_solver-3"><a href="#chebyshev_solver-3"></a>    <span class="co"># Chebyshev grid and mapping to [0,1]</span></span>
<span id="chebyshev_solver-4"><a href="#chebyshev_solver-4"></a>    x <span class="op">=</span> <span class="fu">reverse</span>(<span class="fu">cos</span>.(<span class="cn">pi</span> <span class="op">.*</span> (<span class="fl">0</span><span class="op">:</span>N) <span class="op">./</span> N))</span>
<span id="chebyshev_solver-5"><a href="#chebyshev_solver-5"></a>    s <span class="op">=</span> (x <span class="op">.+</span> <span class="fl">1</span>) <span class="op">./</span> <span class="fl">2</span></span>
<span id="chebyshev_solver-6"><a href="#chebyshev_solver-6"></a>    <span class="co"># Assemble the linear operator</span></span>
<span id="chebyshev_solver-7"><a href="#chebyshev_solver-7"></a>    L, b <span class="op">=</span> <span class="fu">zeros</span>(N<span class="op">+</span><span class="fl">1</span>, N<span class="op">+</span><span class="fl">1</span>), <span class="fu">copy</span>(s)</span>
<span id="chebyshev_solver-8"><a href="#chebyshev_solver-8"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>N<span class="op">+</span><span class="fl">1</span>, j <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>N<span class="op">+</span><span class="fl">1</span></span>
<span id="chebyshev_solver-9"><a href="#chebyshev_solver-9"></a>        TÃÉ, dT, d2T <span class="op">=</span> <span class="fu">chebyshev_derivatives</span>(j<span class="op">-</span><span class="fl">1</span>, s[i]; zmin <span class="op">=</span> <span class="fl">0</span>)</span>
<span id="chebyshev_solver-10"><a href="#chebyshev_solver-10"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="fl">1</span> <span class="op">||</span> i <span class="op">==</span> N<span class="op">+</span><span class="fl">1</span></span>
<span id="chebyshev_solver-11"><a href="#chebyshev_solver-11"></a>            L[i,j] <span class="op">=</span> TÃÉ <span class="co"># Boundary points</span></span>
<span id="chebyshev_solver-12"><a href="#chebyshev_solver-12"></a>        <span class="cf">else</span></span>
<span id="chebyshev_solver-13"><a href="#chebyshev_solver-13"></a>            Œºs <span class="op">=</span> <span class="op">-</span><span class="fl">2</span> <span class="op">*</span> œÉ<span class="op">^</span><span class="fl">2</span> <span class="op">*</span> s[i] <span class="op">*</span> (<span class="fl">1</span> <span class="op">-</span> s[i]) <span class="op">*</span> (s[i] <span class="op">-</span> <span class="fl">1</span><span class="op">/</span><span class="fl">2</span>)</span>
<span id="chebyshev_solver-14"><a href="#chebyshev_solver-14"></a>            œÉs <span class="op">=</span> <span class="fu">sqrt</span>(<span class="fl">2</span>) <span class="op">*</span> œÉ <span class="op">*</span> s[i] <span class="op">*</span> (<span class="fl">1</span> <span class="op">-</span> s[i])</span>
<span id="chebyshev_solver-15"><a href="#chebyshev_solver-15"></a>            L[i,j] <span class="op">=</span> œÅ <span class="op">*</span> TÃÉ <span class="op">-</span> dT <span class="op">*</span> Œºs <span class="op">-</span> d2T <span class="op">*</span> œÉs<span class="op">^</span><span class="fl">2</span> <span class="op">/</span> <span class="fl">2</span></span>
<span id="chebyshev_solver-16"><a href="#chebyshev_solver-16"></a>        <span class="cf">end</span></span>
<span id="chebyshev_solver-17"><a href="#chebyshev_solver-17"></a>    <span class="cf">end</span></span>
<span id="chebyshev_solver-18"><a href="#chebyshev_solver-18"></a>    b[<span class="kw">end</span>] <span class="op">=</span> <span class="fl">1</span><span class="op">/</span>œÅ <span class="co"># Boundary condition at s = 1</span></span>
<span id="chebyshev_solver-19"><a href="#chebyshev_solver-19"></a>    a <span class="op">=</span> L <span class="op">\</span> b  <span class="co"># Solve for the coefficients</span></span>
<span id="chebyshev_solver-20"><a href="#chebyshev_solver-20"></a>    <span class="cf">return</span> (; v <span class="op">=</span> z <span class="op">-&gt;</span> <span class="fu">ChebyshevT</span>(a)(<span class="fl">2</span> <span class="op">*</span> z <span class="op">-</span> <span class="fl">1</span>), s <span class="op">=</span> s) </span>
<span id="chebyshev_solver-21"><a href="#chebyshev_solver-21"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="the-solution-of-the-two-trees-model" class="slide level2 compact-slide">
<h2>The Solution of the Two-trees Model</h2>

<img data-src="Figures/chebyshev_solution.png" style="width:100.0%" class="r-stretch"></section></section>
<section>
<section id="the-challenge-of-high-dimensional-problems-redux" class="title-slide slide level1 center">
<h1>The Challenge of High-Dimensional Problems Redux</h1>

</section>
<section id="finite-difference-methods-in-high-dimensional-problems" class="slide level2 compact-slide">
<h2>Finite Difference Methods in High-Dimensional Problems</h2>
<p>We have seen how to use finite-difference and Chebyshev collocation methods to continuous time models.</p>
<ul>
<li>These techniques are very effective in one or two dimensions.</li>
<li>However, they suffer from the same three <em>curses of dimensionality</em> as in the discrete-time setting.</li>
</ul>
<div class="fragment">
<p><span class="text-blue"><strong>Finite-difference schemes in higher dimensions.</strong></span></p>
<ul>
<li>Because finite-difference schemes represent the state space on a grid, they inherit the first curse of dimensionality.</li>
<li>The number of grid points grows exponentially with the number of state variables</li>
</ul>
</div>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<p>A second difficulty is maintaining the <span class="text-orange"><strong>monotonicity</strong></span> of the scheme.</p>
<ul>
<li>It is straightforward to guarantee monotonicity in one dimension</li>
<li>In higher dimensions, however, cross-derivative terms create complications.</li>
<li>Consider an HJB equation with two state variables <span class="math inline">\(\mathbf{s} = (s_1, s_2)\)</span>:</li>
</ul>
<p><span class="math display">\[
  \rho v = u(\mathbf{s})
  + v_{s_1}\,\mu_{s_1}(\mathbf{s})
  + v_{s_2}\,\mu_{s_2}(\mathbf{s})
  + \tfrac{1}{2}v_{s_1s_1}\,\sigma_{s_1}^2(\mathbf{s})
  + \tfrac{1}{2}v_{s_2s_2}\,\sigma_{s_2}^2(\mathbf{s})
  + v_{s_1s_2}\,\sigma_{s_1s_2}(\mathbf{s}).
\]</span></p>
</div>
<div class="fragment">
<p>A central-difference approximation for the mixed derivative, <span class="math display">\[
  v_{s_1s_2} \approx
  \frac{v_{i+1,j+1} - v_{i-1,j-1} - v_{i+1,j-1} + v_{i-1,j+1}}
       {4 \Delta s_1 \Delta s_2},
\]</span> produces nonnegative off-diagonal elements in the discretization matrix, violating the M-matrix conditions required for stability.</p>
</div>
</section>
<section id="chebyshev-collocation-in-high-dimensional-problems" class="slide level2 compact-slide">
<h2>Chebyshev Collocation in High-Dimensional Problems</h2>
<p>Chebyshev collocation methods share the same first curse.</p>
<ul>
<li>In one dimension, they achieve exponential accuracy with relatively few nodes.</li>
<li>In <span class="math inline">\(d\)</span> dimensions, however, the tensor product of one-dimensional bases yields <span class="math inline">\((N+1)^d\)</span> nodes.</li>
</ul>
<p>Several strategies mitigate this explosion.</p>
<ul>
<li><span class="citation" data-cites="JuddMaliarMaliarValero2014">Judd et al. (<a href="#/references" role="doc-biblioref" onclick="">2014</a>)</span> propose <em>Smolyak sparse grids</em> and <em>anisotropic tensor-product bases</em></li>
<li>This dramatically reduces the number of collocation points.</li>
<li>However, these approaches face steep scaling once <span class="math inline">\(d\)</span> exceeds five to ten dimensions.</li>
</ul>
<div class="fragment">
<div style="margin-top: 1.5em;">

</div>
<div title="The need for new methods">
<div class="callout callout-important callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>The need for new methods</strong></p>
</div>
<div class="callout-content">
<p>Both finite-difference and collocation methods ultimately confront the same exponential barriers as their discrete-time counterparts.</p>
<ul>
<li>In the next modules, we explore modern <span class="text-orange"><strong>machine-learning-based</strong></span> approaches that circumvent these limitations.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="references" class="slide level2 compact-slide smaller scrollable">
<h2>References</h2>
<div class="references">

</div>



<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-achdou2022income" class="csl-entry" role="listitem">
Achdou, Yves, Jiequn Han, Jean-Michel Lasry, Pierre-Louis Lions, and Benjamin Moll. 2022. <span>‚ÄúIncome and Wealth Distribution in Macroeconomics: A Continuous-Time Approach.‚Äù</span> <em>The Review of Economic Studies</em> 89 (1): 45‚Äì86.
</div>
<div id="ref-BarlesSouganidis1991" class="csl-entry" role="listitem">
Barles, Guy, and Panagiotis E. Souganidis. 1991. <span>‚ÄúConvergence of Approximation Schemes for Fully Nonlinear Second Order Equations.‚Äù</span> <em>Asymptotic Analysis</em> 4: 271‚Äì83.
</div>
<div id="ref-Boyd2001" class="csl-entry" role="listitem">
Boyd, John P. 2001. <em>Chebyshev and Fourier Spectral Methods</em>. Mineola, NY: Dover Publications.
</div>
<div id="ref-CochraneLongstaffSantaClara2008" class="csl-entry" role="listitem">
Cochrane, John H., Francis A. Longstaff, and Pedro Santa-Clara. 2008. <span>‚ÄúTwo Trees.‚Äù</span> <em>The Review of Financial Studies</em> 21 (1): 347‚Äì85. <a href="https://doi.org/10.1093/rfs/hhm059">https://doi.org/10.1093/rfs/hhm059</a>.
</div>
<div id="ref-JuddMaliarMaliarValero2014" class="csl-entry" role="listitem">
Judd, Kenneth L., Lilia Maliar, Serguei Maliar, and Rafael Valero. 2014. <span>‚ÄúSmolyak Method for Solving Dynamic Economic Models: Lagrange Interpolation, Anisotropic Grid and Adaptive Domain.‚Äù</span> <em>Journal of Economic Dynamics and Control</em> 44: 92‚Äì123. <a href="https://doi.org/10.1016/j.jedc.2014.03.005">https://doi.org/10.1016/j.jedc.2014.03.005</a>.
</div>
<div id="ref-KushnerDupuis2001" class="csl-entry" role="listitem">
Kushner, Harold J., and Paul G. Dupuis. 2001. <em>Numerical Methods for Stochastic Control Problems in Continuous Time</em>. 2nd ed. Applications of Mathematics 24. New York: Springer.
</div>
<div id="ref-PhelanEslami2022MCA" class="csl-entry" role="listitem">
Phelan, Thomas, and Keyvan Eslami. 2022. <span>‚ÄúApplications of Markov Chain Approximation Methods to Optimal Control Problems in Economics.‚Äù</span> <em>Journal of Economic Dynamics and Control</em> 143: 104437. <a href="https://doi.org/10.1016/j.jedc.2022.104437">https://doi.org/10.1016/j.jedc.2022.104437</a>.
</div>
</div>
</section></section>
    </div>
  <div class="quarto-auto-generated-content" style="display: none;">
<div class="footer footer-default">

</div>
</div></div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="../site_libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="../site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="../site_libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="../site_libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="../site_libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="../site_libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="../site_libs/revealjs/plugin/notes/notes.js"></script>
  <script src="../site_libs/revealjs/plugin/search/search.js"></script>
  <script src="../site_libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="../site_libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': true,
'previewLinksAuto': false,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'jumpToSlide': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleScrollView(event)\"><kbd>r</kbd> Scroll View Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"5\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":true},
'smaller': false,
 
        // Display controls in the bottom right corner
        controls: false,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'none',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1050,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        math: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@2.7.9/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, QuartoSupport,

          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script>
    function greyOutPreviousFragments(slide) {
      if (!slide || slide.dataset.greyPrevious !== 'true') return;
      
      const fragments = Array
        .from(slide.querySelectorAll('.fragment[data-fragment-index]'))
        .sort(
          (a, b) =>
            (Number(a.dataset.fragmentIndex) || 0) -
            (Number(b.dataset.fragmentIndex) || 0)
        );
      
      if (!fragments.length) return;
      
      fragments.forEach(frag => {
        frag.style.transition = 'opacity 0.8s ease-in-out, color 0.8s ease-in-out';
      });
      
      const visibleFragments = fragments.filter(frag =>
        frag.classList.contains('visible') ||
        frag.classList.contains('current-fragment')
      );
      const maxVisibleIndex = visibleFragments.length
        ? Math.max(
            ...visibleFragments.map(frag => Number(frag.dataset.fragmentIndex) || 0)
          )
        : -1;
      
      fragments.forEach(frag => {
        const fragIndex = Number(frag.dataset.fragmentIndex) || 0;
        if (fragIndex < maxVisibleIndex) {
          frag.style.opacity = '0.4';
          frag.style.color = '#808080';
        } else {
          frag.style.opacity = '1';
          frag.style.color = '';
        }
      });
    }

    Reveal.addEventListener('slidechanged', function(event) {
      setTimeout(() => greyOutPreviousFragments(event.currentSlide), 100);
    });

    Reveal.addEventListener('fragmentshown', function(event) {
      const slide = event.fragment.closest('section');
      setTimeout(() => greyOutPreviousFragments(slide), 50);
    });

    Reveal.addEventListener('fragmenthidden', function(event) {
      const slide = event.fragment.closest('section');
      setTimeout(() => greyOutPreviousFragments(slide), 50);
    });

    // Also check on initial load
    Reveal.addEventListener('ready', function(event) {
      setTimeout(() => {
        document
          .querySelectorAll('section[data-grey-previous="true"]')
          .forEach(slide => greyOutPreviousFragments(slide));
      }, 100);
    });

    // Add line-by-line highlighting to code blocks
    function setupLineByLineHighlighting() {
      const allPre = document.querySelectorAll('pre code');
      allPre.forEach(code => {
        const pre = code.parentElement;
        if (pre && pre.tagName === 'PRE' && !pre.dataset.lineNumbersSetup) {
          let lineNumbers = null;
          
          // Check for vf_iteration function
          if (code.textContent.includes('function vf_iteration')) {
            lineNumbers = '1|2|3|4|5|6|7|8|9|10|11|12|13|14|15';
          }
          // Check for tauchen function
          else if (code.textContent.includes('function tauchen')) {
            lineNumbers = '1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32';
          }
          
          if (lineNumbers) {
            // Set data-line-numbers attribute (Reveal.js should handle this)
            pre.setAttribute('data-line-numbers', lineNumbers);
            
            // Add CSS for line highlighting (fallback if plugin doesn't work)
            if (!document.getElementById('line-highlight-style')) {
              const style = document.createElement('style');
              style.id = 'line-highlight-style';
              style.textContent = `
                pre[data-line-numbers] code {
                  counter-reset: line;
                }
                pre[data-line-numbers] code .hljs-line::before {
                  counter-increment: line;
                  content: counter(line);
                  display: inline-block;
                  width: 2em;
                  padding-right: 1em;
                  color: #999;
                  text-align: right;
                }
                /* Highlight current line based on fragment */
                pre[data-line-numbers] code .hljs-line.fragment.visible {
                  background-color: rgba(255, 255, 0, 0.2);
                }
              `;
              document.head.appendChild(style);
            }
            
            console.log('Set data-line-numbers attribute on code block');
            pre.dataset.lineNumbersSetup = 'true';
          }
        }
      });
    }

    // Try multiple times to catch the code when it's rendered
    function trySetupLineNumbers() {
      setupLineByLineHighlighting();
      setTimeout(setupLineByLineHighlighting, 200);
      setTimeout(setupLineByLineHighlighting, 500);
      setTimeout(setupLineByLineHighlighting, 1000);
      setTimeout(setupLineByLineHighlighting, 2000);
    }

    Reveal.addEventListener('ready', function(event) {
      console.log('Reveal.js ready, setting up line numbers');
      trySetupLineNumbers();
    });

    Reveal.addEventListener('slidechanged', function(event) {
      setTimeout(setupLineByLineHighlighting, 200);
    });

    // Also use MutationObserver to catch when code is added
    const observer = new MutationObserver(function(mutations) {
      setupLineByLineHighlighting();
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true
    });

    // Add footer with link back to homepage
    function addHomepageFooter() {
      // Check if footer already exists
      if (document.getElementById('homepage-footer')) return;
      
      // All slides are in Module subdirectories, so go up one level to reach index.html
      const homePath = '../index.html';
      
      // Create footer element
      const footer = document.createElement('div');
      footer.id = 'homepage-footer';
      footer.innerHTML = '<a href="' + homePath + '" title="Back to homepage">üè†</a>';
      
      // Add to reveal container
      const revealContainer = document.querySelector('.reveal');
      if (revealContainer) {
        revealContainer.appendChild(footer);
      }
    }

    // Add footer when Reveal is ready
    if (typeof Reveal !== 'undefined') {
      Reveal.addEventListener('ready', function(event) {
        addHomepageFooter();
      });
    } else {
      // Fallback: wait for Reveal to be available
      window.addEventListener('load', function() {
        if (typeof Reveal !== 'undefined') {
          Reveal.addEventListener('ready', function(event) {
            addHomepageFooter();
          });
          // Try immediately in case Reveal is already ready
          setTimeout(addHomepageFooter, 100);
        }
      });
    }
    </script>

    <style>
    /* Footer with link back to homepage */
    .reveal #homepage-footer {
      position: fixed;
      bottom: 20px;
      right: 70px;
      z-index: 1000;
      font-size: 0.5em;
      opacity: 0.5;
      transition: opacity 0.3s ease;
    }

    .reveal #homepage-footer:hover {
      opacity: 1;
    }

    .reveal #homepage-footer a {
      color: #0072b2;
      text-decoration: none;
      padding: 3px 5px;
      background-color: rgba(255, 255, 255, 0.9);
      border-radius: 3px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      display: inline-block;
      transition: background-color 0.3s ease, transform 0.2s ease;
      line-height: 1;
    }

    .reveal #homepage-footer a:hover {
      background-color: #0072b2;
      transform: scale(1.1);
      text-decoration: none;
    }

    /* Hide footer on title slide if desired */
    .reveal #title-slide ~ #homepage-footer,
    .reveal section#title-slide ~ #homepage-footer {
      display: none;
    }
    </style>

    <script id="quarto-html-after-body" type="application/javascript">
      window.document.addEventListener("DOMContentLoaded", function (event) {
        const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
        tabsets.forEach(function(tabset) {
          const tabby = new Tabby('#' + tabset.id);
        });
        const isCodeAnnotation = (el) => {
          for (const clz of el.classList) {
            if (clz.startsWith('code-annotation-')) {                     
              return true;
            }
          }
          return false;
        }
        const onCopySuccess = function(e) {
          // button target
          const button = e.trigger;
          // don't keep focus
          button.blur();
          // flash "checked"
          button.classList.add('code-copy-button-checked');
          var currentTitle = button.getAttribute("title");
          button.setAttribute("title", "Copied!");
          let tooltip;
          if (window.bootstrap) {
            button.setAttribute("data-bs-toggle", "tooltip");
            button.setAttribute("data-bs-placement", "left");
            button.setAttribute("data-bs-title", "Copied!");
            tooltip = new bootstrap.Tooltip(button, 
              { trigger: "manual", 
                customClass: "code-copy-button-tooltip",
                offset: [0, -8]});
            tooltip.show();    
          }
          setTimeout(function() {
            if (tooltip) {
              tooltip.hide();
              button.removeAttribute("data-bs-title");
              button.removeAttribute("data-bs-toggle");
              button.removeAttribute("data-bs-placement");
            }
            button.setAttribute("title", currentTitle);
            button.classList.remove('code-copy-button-checked');
          }, 1000);
          // clear code selection
          e.clearSelection();
        }
        const getTextToCopy = function(trigger) {
          const outerScaffold = trigger.parentElement.cloneNode(true);
          const codeEl = outerScaffold.querySelector('code');
          for (const childEl of codeEl.children) {
            if (isCodeAnnotation(childEl)) {
              childEl.remove();
            }
          }
          return codeEl.innerText;
        }
        const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
          text: getTextToCopy
        });
        clipboard.on('success', onCopySuccess);
        if (window.document.getElementById('quarto-embedded-source-code-modal')) {
          const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
            text: getTextToCopy,
            container: window.document.getElementById('quarto-embedded-source-code-modal')
          });
          clipboardModal.on('success', onCopySuccess);
        }
          var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
          var mailtoRegex = new RegExp(/^mailto:/);
            var filterRegex = new RegExp('/' + window.location.host + '/');
          var isInternal = (href) => {
              return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
          }
          // Inspect non-navigation links and adorn them if external
         var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
          for (var i=0; i<links.length; i++) {
            const link = links[i];
            if (!isInternal(link.href)) {
              // undo the damage that might have been done by quarto-nav.js in the case of
              // links that we want to consider external
              if (link.dataset.originalHref !== undefined) {
                link.href = link.dataset.originalHref;
              }
            }
          }
        function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
          const config = {
            allowHTML: true,
            maxWidth: 500,
            delay: 100,
            arrow: false,
            appendTo: function(el) {
                return el.closest('section.slide') || el.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'light-border',
            placement: 'bottom-start',
          };
          if (contentFn) {
            config.content = contentFn;
          }
          if (onTriggerFn) {
            config.onTrigger = onTriggerFn;
          }
          if (onUntriggerFn) {
            config.onUntrigger = onUntriggerFn;
          }
            config['offset'] = [0,0];
            config['maxWidth'] = 700;
          window.tippy(el, config); 
        }
        const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
        for (var i=0; i<noterefs.length; i++) {
          const ref = noterefs[i];
          tippyHover(ref, function() {
            // use id or data attribute instead here
            let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
            try { href = new URL(href).hash; } catch {}
            const id = href.replace(/^#\/?/, "");
            const note = window.document.getElementById(id);
            if (note) {
              return note.innerHTML;
            } else {
              return "";
            }
          });
        }
        const findCites = (el) => {
          const parentEl = el.parentElement;
          if (parentEl) {
            const cites = parentEl.dataset.cites;
            if (cites) {
              return {
                el,
                cites: cites.split(' ')
              };
            } else {
              return findCites(el.parentElement)
            }
          } else {
            return undefined;
          }
        };
        var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
        for (var i=0; i<bibliorefs.length; i++) {
          const ref = bibliorefs[i];
          const citeInfo = findCites(ref);
          if (citeInfo) {
            tippyHover(citeInfo.el, function() {
              var popup = window.document.createElement('div');
              citeInfo.cites.forEach(function(cite) {
                var citeDiv = window.document.createElement('div');
                citeDiv.classList.add('hanging-indent');
                citeDiv.classList.add('csl-entry');
                var biblioDiv = window.document.getElementById('ref-' + cite);
                if (biblioDiv) {
                  citeDiv.innerHTML = biblioDiv.innerHTML;
                }
                popup.appendChild(citeDiv);
              });
              return popup.innerHTML;
            });
          }
        }
      });
      </script>
    

</body></html>